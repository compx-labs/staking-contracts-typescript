/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"irpfg","structs":{"StakeInfoRecord":[{"name":"stake","type":"uint64"},{"name":"lastRewardIndex","type":"uint64"}]},"methods":[{"name":"createApplication","args":[{"type":"address","name":"adminAddress"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"initApplication","args":[{"type":"uint64","name":"stakedAssetId","desc":"- The asset ID of the token to be staked in the pool."},{"type":"uint64","name":"rewardAssetId","desc":"- The asset ID of the token to be distributed as rewards."},{"type":"pay","name":"initialBalanceTxn","desc":"- The payment transaction providing the initial minimum balance for the contract."},{"type":"uint64","name":"fluxTierRequired"},{"type":"application","name":"fluxOracleApp"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Initializes the staking pool application with the specified staked asset and reward asset.\n\nSets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset\nand reward asset if necesary.\nOnly the admin address can call this function.","events":[],"recommendations":{}},{"name":"updateAdminAddress","args":[{"type":"account","name":"adminAddress"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"injectRewards","args":[{"type":"axfer","name":"rewardTxn"},{"type":"uint64","name":"quantity"},{"type":"uint64","name":"rewardAssetId"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"deleteApplication","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["DeleteApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"stake","args":[{"type":"axfer","name":"stakeTxn"},{"type":"uint64","name":"quantity"},{"type":"pay","name":"mbrTxn"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"claimRewards","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"unstake","args":[{"type":"uint64","name":"quantity"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"gas","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":1,"bytes":9},"local":{"ints":0,"bytes":0}},"keys":{"global":{"staked_asset_id":{"keyType":"AVMString","valueType":"uint64","key":"c3Rha2VkX2Fzc2V0X2lk"},"reward_asset_id":{"keyType":"AVMString","valueType":"uint64","key":"cmV3YXJkX2Fzc2V0X2lk"},"total_staked":{"keyType":"AVMString","valueType":"uint64","key":"dG90YWxfc3Rha2Vk"},"current_asa_reward_index":{"keyType":"AVMString","valueType":"uint64","key":"Y3VycmVudF9hc2FfcmV3YXJkX2luZGV4"},"last_reward_injection_time":{"keyType":"AVMString","valueType":"uint64","key":"bGFzdF9yZXdhcmRfaW5qZWN0aW9uX3RpbWU="},"admin_address":{"keyType":"AVMString","valueType":"address","key":"YWRtaW5fYWRkcmVzcw=="},"num_stakers":{"keyType":"AVMString","valueType":"uint64","key":"bnVtX3N0YWtlcnM="},"contract_version":{"keyType":"AVMString","valueType":"uint64","key":"Y29udHJhY3RfdmVyc2lvbg=="},"flux_tier_required":{"keyType":"AVMString","valueType":"uint8","key":"Zmx1eF90aWVyX3JlcXVpcmVk"},"flux_oracle_app":{"keyType":"AVMString","valueType":"AVMUint64","key":"Zmx1eF9vcmFjbGVfYXBw"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"stakers":{"keyType":"address","valueType":"StakeInfoRecord","prefix":"c3Q="}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[1004,1014,1038,1081,1098,1185,1313,1435],"errorMessage":"Box must have value"},{"pc":[960],"errorMessage":"Bytes has valid prefix"},{"pc":[1099,1187,1326],"errorMessage":"Index access is out of bounds"},{"pc":[969],"errorMessage":"Insufficient flux tier"},{"pc":[817],"errorMessage":"Invalid quantity"},{"pc":[1195,1321],"errorMessage":"No stake"},{"pc":[1179,1303],"errorMessage":"No stake found for user"},{"pc":[344],"errorMessage":"OnCompletion is not DeleteApplication"},{"pc":[268,277,293,305,356,386,404,444],"errorMessage":"OnCompletion is not NoOp"},{"pc":[735],"errorMessage":"Only admin can delete application"},{"pc":[504],"errorMessage":"Only admin can init application"},{"pc":[659],"errorMessage":"Only admin can inject rewards"},{"pc":[643],"errorMessage":"Only admin can update admin address"},{"pc":[742],"errorMessage":"Staked assets still exist"},{"pc":[908],"errorMessage":"application exists"},{"pc":[581,703,863,897],"errorMessage":"assert target is match for conditions"},{"pc":[448],"errorMessage":"can only call when creating"},{"pc":[271,280,296,308,347,359,389,407],"errorMessage":"can only call when not creating"},{"pc":[502,641,657,667,707,733,739,748,774,779,789,846,902,966,984,989,997,1020,1056,1067,1112,1129,1141,1153,1199,1210,1231,1248,1274,1332,1340,1351,1374,1387,1392,1409,1420,1441,1486,1522,1543,1567],"errorMessage":"check GlobalState exists"},{"pc":[545],"errorMessage":"overflow"},{"pc":[319,369],"errorMessage":"transaction type is axfer"},{"pc":[333,425],"errorMessage":"transaction type is pay"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQgMTAwMCAxMDAwMDAwMDAwMDAwMDAwCiAgICBieXRlY2Jsb2NrICJzdCIgImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIgInRvdGFsX3N0YWtlZCIgImFkbWluX2FkZHJlc3MiICJzdGFrZWRfYXNzZXRfaWQiICJyZXdhcmRfYXNzZXRfaWQiICJudW1fc3Rha2VycyIgMHgwMDAwMDAwMDAwMDAwMDAwICJsYXN0X3Jld2FyZF9pbmplY3Rpb25fdGltZSIgImZsdXhfdGllcl9yZXF1aXJlZCIgImZsdXhfb3JhY2xlX2FwcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIyLTIzCiAgICAvLyBAY29udHJhY3QoeyBuYW1lOiAiaXJwZmciLCBhdm1WZXJzaW9uOiAxMSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEluamVjdGVkUmV3YXJkc1Bvb2xGbHV4R2F0ZWQgZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDE1CiAgICBwdXNoYnl0ZXNzIDB4ZDMyNGJlYTQgMHg5NDIwMjA2NCAweDMyZGI3YTZkIDB4MzQ3MDA3ZWIgMHgyNDg3YzMyYyAweDdhOWVlMTg5IDB4YTVhZTZiZDEgMHg4MTNjZTg5YSAweDMxNzJjYTlkIC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJpbml0QXBwbGljYXRpb24odWludDY0LHVpbnQ2NCxwYXksdWludDY0LGFwcGxpY2F0aW9uKXZvaWQiLCBtZXRob2QgInVwZGF0ZUFkbWluQWRkcmVzcyhhY2NvdW50KXZvaWQiLCBtZXRob2QgImluamVjdFJld2FyZHMoYXhmZXIsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIsIG1ldGhvZCAic3Rha2UoYXhmZXIsdWludDY0LHBheSl2b2lkIiwgbWV0aG9kICJjbGFpbVJld2FyZHMoKXZvaWQiLCBtZXRob2QgInVuc3Rha2UodWludDY0KXZvaWQiLCBtZXRob2QgImdhcygpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY3JlYXRlQXBwbGljYXRpb25fcm91dGVAMyBtYWluX2luaXRBcHBsaWNhdGlvbl9yb3V0ZUA0IG1haW5fdXBkYXRlQWRtaW5BZGRyZXNzX3JvdXRlQDUgbWFpbl9pbmplY3RSZXdhcmRzX3JvdXRlQDYgbWFpbl9kZWxldGVBcHBsaWNhdGlvbl9yb3V0ZUA3IG1haW5fc3Rha2Vfcm91dGVAOCBtYWluX2NsYWltUmV3YXJkc19yb3V0ZUA5IG1haW5fdW5zdGFrZV9yb3V0ZUAxMCBtYWluX2dhc19yb3V0ZUAxMQoKbWFpbl9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjItMjMKICAgIC8vIEBjb250cmFjdCh7IG5hbWU6ICJpcnBmZyIsIGF2bVZlcnNpb246IDExIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgSW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZCBleHRlbmRzIENvbnRyYWN0IHsKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fZ2FzX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzI3CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91bnN0YWtlX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYxCiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjItMjMKICAgIC8vIEBjb250cmFjdCh7IG5hbWU6ICJpcnBmZyIsIGF2bVZlcnNpb246IDExIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgSW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2MQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiIH0pCiAgICBjYWxsc3ViIHVuc3Rha2UKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY2xhaW1SZXdhcmRzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMjgKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICJOb09wIiB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGNsYWltUmV3YXJkcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zdGFrZV9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTYwCiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjItMjMKICAgIC8vIEBjb250cmFjdCh7IG5hbWU6ICJpcnBmZyIsIGF2bVZlcnNpb246IDExIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgSW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4biBHcm91cEluZGV4CiAgICBwdXNoaW50IDIgLy8gMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgYXhmZXIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTYwCiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIGNhbGxzdWIgc3Rha2UKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVsZXRlQXBwbGljYXRpb25fcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEzMQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIkRlbGV0ZUFwcGxpY2F0aW9uIiB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVBcHBsaWNhdGlvbgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9pbmplY3RSZXdhcmRzX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMTcKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICJOb09wIiB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMi0yMwogICAgLy8gQGNvbnRyYWN0KHsgbmFtZTogImlycGZnIiwgYXZtVmVyc2lvbjogMTEgfSkKICAgIC8vIGV4cG9ydCBjbGFzcyBJbmplY3RlZFJld2FyZHNQb29sRmx1eEdhdGVkIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBheGZlcgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTE3CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIGNhbGxzdWIgaW5qZWN0UmV3YXJkcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVBZG1pbkFkZHJlc3Nfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEwOAogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIyLTIzCiAgICAvLyBAY29udHJhY3QoeyBuYW1lOiAiaXJwZmciLCBhdm1WZXJzaW9uOiAxMSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEluamVjdGVkUmV3YXJkc1Bvb2xGbHV4R2F0ZWQgZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTA4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIGNhbGxzdWIgdXBkYXRlQWRtaW5BZGRyZXNzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2luaXRBcHBsaWNhdGlvbl9yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NjQKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICJOb09wIiB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMi0yMwogICAgLy8gQGNvbnRyYWN0KHsgbmFtZTogImlycGZnIiwgYXZtVmVyc2lvbjogMTEgfSkKICAgIC8vIGV4cG9ydCBjbGFzcyBJbmplY3RlZFJld2FyZHNQb29sRmx1eEdhdGVkIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjY0CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIGNhbGxzdWIgaW5pdEFwcGxpY2F0aW9uCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZUFwcGxpY2F0aW9uX3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo0OAogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiLCBvbkNyZWF0ZTogInJlcXVpcmUiIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjItMjMKICAgIC8vIEBjb250cmFjdCh7IG5hbWU6ICJpcnBmZyIsIGF2bVZlcnNpb246IDExIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgSW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjQ4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIsIG9uQ3JlYXRlOiAicmVxdWlyZSIgfSkKICAgIGNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo6SW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZC5jcmVhdGVBcHBsaWNhdGlvbihhZG1pbkFkZHJlc3M6IGJ5dGVzKSAtPiB2b2lkOgpjcmVhdGVBcHBsaWNhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjQ4LTQ5CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIsIG9uQ3JlYXRlOiAicmVxdWlyZSIgfSkKICAgIC8vIGNyZWF0ZUFwcGxpY2F0aW9uKGFkbWluQWRkcmVzczogQWRkcmVzcyk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozOAogICAgLy8gYWRtaW5fYWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KCk7CiAgICBieXRlY18zIC8vICJhZG1pbl9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NTAKICAgIC8vIHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSA9IGFkbWluQWRkcmVzcy5uYXRpdmU7CiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo0MgogICAgLy8gY29udHJhY3RfdmVyc2lvbiA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBwdXNoYnl0ZXNzICJjb250cmFjdF92ZXJzaW9uIiAweDAwMDAwMDAwMDAwMDBmYTAgLy8gImNvbnRyYWN0X3ZlcnNpb24iLCAweDAwMDAwMDAwMDAwMDBmYTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjUxCiAgICAvLyB0aGlzLmNvbnRyYWN0X3ZlcnNpb24udmFsdWUgPSBuZXcgVWludE42NChWRVJTSU9OKTsKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo6SW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZC5pbml0QXBwbGljYXRpb24oc3Rha2VkQXNzZXRJZDogdWludDY0LCByZXdhcmRBc3NldElkOiB1aW50NjQsIGluaXRpYWxCYWxhbmNlVHhuOiB1aW50NjQsIGZsdXhUaWVyUmVxdWlyZWQ6IHVpbnQ2NCwgZmx1eE9yYWNsZUFwcDogdWludDY0KSAtPiB2b2lkOgppbml0QXBwbGljYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo2NC03MQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiIH0pCiAgICAvLyBpbml0QXBwbGljYXRpb24oCiAgICAvLyAgIHN0YWtlZEFzc2V0SWQ6IHVpbnQ2NCwKICAgIC8vICAgcmV3YXJkQXNzZXRJZDogdWludDY0LAogICAgLy8gICBpbml0aWFsQmFsYW5jZVR4bjogZ3R4bi5QYXltZW50VHhuLAogICAgLy8gICBmbHV4VGllclJlcXVpcmVkOiB1aW50NjQsCiAgICAvLyAgIGZsdXhPcmFjbGVBcHA6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHByb3RvIDUgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzIKICAgIC8vIGFzc2VydChvcC5UeG4uc2VuZGVyID09PSB0aGlzLmFkbWluX2FkZHJlc3MudmFsdWUsICJPbmx5IGFkbWluIGNhbiBpbml0IGFwcGxpY2F0aW9uIik7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozOAogICAgLy8gYWRtaW5fYWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW5fYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo3MgogICAgLy8gYXNzZXJ0KG9wLlR4bi5zZW5kZXIgPT09IHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIGluaXQgYXBwbGljYXRpb24iKTsKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gaW5pdCBhcHBsaWNhdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzQKICAgIC8vIHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlID0gbmV3IFVpbnRONjQoc3Rha2VkQXNzZXRJZCk7CiAgICBmcmFtZV9kaWcgLTUKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4CiAgICAvLyBzdGFrZWRfYXNzZXRfaWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWMgNCAvLyAic3Rha2VkX2Fzc2V0X2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzQKICAgIC8vIHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlID0gbmV3IFVpbnRONjQoc3Rha2VkQXNzZXRJZCk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzUKICAgIC8vIHRoaXMucmV3YXJkX2Fzc2V0X2lkLnZhbHVlID0gbmV3IFVpbnRONjQocmV3YXJkQXNzZXRJZCk7CiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwCiAgICAvLyByZXdhcmRfYXNzZXRfaWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWMgNSAvLyAicmV3YXJkX2Fzc2V0X2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzUKICAgIC8vIHRoaXMucmV3YXJkX2Fzc2V0X2lkLnZhbHVlID0gbmV3IFVpbnRONjQocmV3YXJkQXNzZXRJZCk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBieXRlY18yIC8vICJ0b3RhbF9zdGFrZWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo3NgogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCgwKTsKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzYKICAgIC8vIGxhc3RfcmV3YXJkX2luamVjdGlvbl90aW1lID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjIDggLy8gImxhc3RfcmV3YXJkX2luamVjdGlvbl90aW1lIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzcKICAgIC8vIHRoaXMubGFzdF9yZXdhcmRfaW5qZWN0aW9uX3RpbWUudmFsdWUgPSBuZXcgVWludE42NCgwKTsKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzQKICAgIC8vIGN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBieXRlY18xIC8vICJjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo3OAogICAgLy8gdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUgPSBuZXcgVWludE42NCgwKTsKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NDAKICAgIC8vIG51bV9zdGFrZXJzID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjIDYgLy8gIm51bV9zdGFrZXJzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NzkKICAgIC8vIHRoaXMubnVtX3N0YWtlcnMudmFsdWUgPSBuZXcgVWludE42NCgwKTsKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6ODAKICAgIC8vIHRoaXMuZmx1eF90aWVyX3JlcXVpcmVkLnZhbHVlID0gbmV3IFVpbnROOChmbHV4VGllclJlcXVpcmVkKTsKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NDQKICAgIC8vIGZsdXhfdGllcl9yZXF1aXJlZCA9IEdsb2JhbFN0YXRlPFVpbnROOD4oKTsKICAgIGJ5dGVjIDkgLy8gImZsdXhfdGllcl9yZXF1aXJlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjgwCiAgICAvLyB0aGlzLmZsdXhfdGllcl9yZXF1aXJlZC52YWx1ZSA9IG5ldyBVaW50TjgoZmx1eFRpZXJSZXF1aXJlZCk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NDYKICAgIC8vIGZsdXhfb3JhY2xlX2FwcCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPigpOwogICAgYnl0ZWMgMTAgLy8gImZsdXhfb3JhY2xlX2FwcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjgxCiAgICAvLyB0aGlzLmZsdXhfb3JhY2xlX2FwcC52YWx1ZSA9IGZsdXhPcmFjbGVBcHA7CiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo4My04NgogICAgLy8gYXNzZXJ0TWF0Y2goaW5pdGlhbEJhbGFuY2VUeG4sIHsKICAgIC8vICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IElOSVRJQUxfUEFZX0FNT1VOVCwKICAgIC8vIH0pOwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6ODQKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo4My04NgogICAgLy8gYXNzZXJ0TWF0Y2goaW5pdGlhbEJhbGFuY2VUeG4sIHsKICAgIC8vICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IElOSVRJQUxfUEFZX0FNT1VOVCwKICAgIC8vIH0pOwogICAgPT0KICAgIGJ6IGluaXRBcHBsaWNhdGlvbl9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MTUKICAgIC8vIGV4cG9ydCBjb25zdCBJTklUSUFMX1BBWV9BTU9VTlQ6IHVpbnQ2NCA9IDQwMF8wMDA7CiAgICBwdXNoaW50IDQwMDAwMCAvLyA0MDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjgzLTg2CiAgICAvLyBhc3NlcnRNYXRjaChpbml0aWFsQmFsYW5jZVR4biwgewogICAgLy8gICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogSU5JVElBTF9QQVlfQU1PVU5ULAogICAgLy8gfSk7CiAgICA9PQogICAgYnogaW5pdEFwcGxpY2F0aW9uX2Jvb2xfZmFsc2VAMwogICAgaW50Y18xIC8vIDEKCmluaXRBcHBsaWNhdGlvbl9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo4My04NgogICAgLy8gYXNzZXJ0TWF0Y2goaW5pdGlhbEJhbGFuY2VUeG4sIHsKICAgIC8vICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IElOSVRJQUxfUEFZX0FNT1VOVCwKICAgIC8vIH0pOwogICAgYXNzZXJ0IC8vIGFzc2VydCB0YXJnZXQgaXMgbWF0Y2ggZm9yIGNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjg4LTk1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHN0YWtlZEFzc2V0SWQsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo5MQogICAgLy8gYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6OTIKICAgIC8vIGFzc2V0QW1vdW50OiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC01CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6ODgtOTQKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogc3Rha2VkQXNzZXRJZCwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIH0pCiAgICBpbnRjXzIgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjE2CiAgICAvLyBleHBvcnQgY29uc3QgU1RBTkRBUkRfVFhOX0ZFRTogdWludDY0ID0gMV8wMDA7CiAgICBpbnRjXzMgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjg4LTk1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHN0YWtlZEFzc2V0SWQsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6OTYKICAgIC8vIGlmIChyZXdhcmRBc3NldElkICE9PSBzdGFrZWRBc3NldElkKSB7CiAgICBmcmFtZV9kaWcgLTQKICAgIGZyYW1lX2RpZyAtNQogICAgIT0KICAgIGJ6IGluaXRBcHBsaWNhdGlvbl9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjk3LTEwNAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgeGZlckFzc2V0OiByZXdhcmRBc3NldElkLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTAwCiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMDEKICAgIC8vIGFzc2V0QW1vdW50OiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC00CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6OTctMTAzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHJld2FyZEFzc2V0SWQsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgaW50Y18yIC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoxNgogICAgLy8gZXhwb3J0IGNvbnN0IFNUQU5EQVJEX1RYTl9GRUU6IHVpbnQ2NCA9IDFfMDAwOwogICAgaW50Y18zIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo5Ny0xMDQKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogcmV3YXJkQXNzZXRJZCwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fc3VibWl0Cgppbml0QXBwbGljYXRpb25fYWZ0ZXJfaWZfZWxzZUA4OgogICAgcmV0c3ViCgppbml0QXBwbGljYXRpb25fYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgaW5pdEFwcGxpY2F0aW9uX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjpJbmplY3RlZFJld2FyZHNQb29sRmx1eEdhdGVkLnVwZGF0ZUFkbWluQWRkcmVzcyhhZG1pbkFkZHJlc3M6IGJ5dGVzKSAtPiB2b2lkOgp1cGRhdGVBZG1pbkFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMDgtMTA5CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIC8vIHVwZGF0ZUFkbWluQWRkcmVzcyhhZG1pbkFkZHJlc3M6IEFjY291bnQpOiB2b2lkIHsKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTEwCiAgICAvLyBhc3NlcnQob3AuVHhuLnNlbmRlciA9PT0gdGhpcy5hZG1pbl9hZGRyZXNzLnZhbHVlLCAiT25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluIGFkZHJlc3MiKTsKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM4CiAgICAvLyBhZG1pbl9hZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJhZG1pbl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjExMAogICAgLy8gYXNzZXJ0KG9wLlR4bi5zZW5kZXIgPT09IHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbiBhZGRyZXNzIik7CiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbiBhZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozOAogICAgLy8gYWRtaW5fYWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KCk7CiAgICBieXRlY18zIC8vICJhZG1pbl9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTExCiAgICAvLyB0aGlzLmFkbWluX2FkZHJlc3MudmFsdWUgPSBhZG1pbkFkZHJlc3M7CiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo6SW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZC5pbmplY3RSZXdhcmRzKHJld2FyZFR4bjogdWludDY0LCBxdWFudGl0eTogdWludDY0LCByZXdhcmRBc3NldElkOiB1aW50NjQpIC0+IHZvaWQ6CmluamVjdFJld2FyZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMTctMTE4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiAiTm9PcCIgfSkKICAgIC8vIGluamVjdFJld2FyZHMocmV3YXJkVHhuOiBndHhuLkFzc2V0VHJhbnNmZXJUeG4sIHF1YW50aXR5OiB1aW50NjQsIHJld2FyZEFzc2V0SWQ6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMTkKICAgIC8vIGFzc2VydChvcC5UeG4uc2VuZGVyID09PSB0aGlzLmFkbWluX2FkZHJlc3MudmFsdWUsICJPbmx5IGFkbWluIGNhbiBpbmplY3QgcmV3YXJkcyIpOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzgKICAgIC8vIGFkbWluX2FkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gImFkbWluX2FkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTE5CiAgICAvLyBhc3NlcnQob3AuVHhuLnNlbmRlciA9PT0gdGhpcy5hZG1pbl9hZGRyZXNzLnZhbHVlLCAiT25seSBhZG1pbiBjYW4gaW5qZWN0IHJld2FyZHMiKTsKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gaW5qZWN0IHJld2FyZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEyMS0xMjYKICAgIC8vIGFzc2VydE1hdGNoKHJld2FyZFR4biwgewogICAgLy8gICBzZW5kZXI6IHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkQXNzZXRJZCksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM4CiAgICAvLyBhZG1pbl9hZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJhZG1pbl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEyMS0xMjYKICAgIC8vIGFzc2VydE1hdGNoKHJld2FyZFR4biwgewogICAgLy8gICBzZW5kZXI6IHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkQXNzZXRJZCksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgPT0KICAgIGJ6IGluamVjdFJld2FyZHNfYm9vbF9mYWxzZUA1CiAgICBmcmFtZV9kaWcgLTMKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEyMwogICAgLy8gYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTIxLTEyNgogICAgLy8gYXNzZXJ0TWF0Y2gocmV3YXJkVHhuLCB7CiAgICAvLyAgIHNlbmRlcjogdGhpcy5hZG1pbl9hZGRyZXNzLnZhbHVlLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBBc3NldChyZXdhcmRBc3NldElkKSwKICAgIC8vICAgYXNzZXRBbW91bnQ6IHF1YW50aXR5LAogICAgLy8gfSk7CiAgICA9PQogICAgYnogaW5qZWN0UmV3YXJkc19ib29sX2ZhbHNlQDUKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBieiBpbmplY3RSZXdhcmRzX2Jvb2xfZmFsc2VANQogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYnogaW5qZWN0UmV3YXJkc19ib29sX2ZhbHNlQDUKICAgIGludGNfMSAvLyAxCgppbmplY3RSZXdhcmRzX2Jvb2xfbWVyZ2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEyMS0xMjYKICAgIC8vIGFzc2VydE1hdGNoKHJld2FyZFR4biwgewogICAgLy8gICBzZW5kZXI6IHRoaXMuYWRtaW5fYWRkcmVzcy52YWx1ZSwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkQXNzZXRJZCksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgYXNzZXJ0IC8vIGFzc2VydCB0YXJnZXQgaXMgbWF0Y2ggZm9yIGNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMjcKICAgIC8vIHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlID0gbmV3IFVpbnRONjQodGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUubmF0aXZlICsgcXVhbnRpdHkpOwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICArCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozNAogICAgLy8gY3VycmVudF9hc2FfcmV3YXJkX2luZGV4ID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEyNwogICAgLy8gdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZS5uYXRpdmUgKyBxdWFudGl0eSk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTI4CiAgICAvLyB0aGlzLmxhc3RfcmV3YXJkX2luamVjdGlvbl90aW1lLnZhbHVlID0gbmV3IFVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCk7CiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozNgogICAgLy8gbGFzdF9yZXdhcmRfaW5qZWN0aW9uX3RpbWUgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWMgOCAvLyAibGFzdF9yZXdhcmRfaW5qZWN0aW9uX3RpbWUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMjgKICAgIC8vIHRoaXMubGFzdF9yZXdhcmRfaW5qZWN0aW9uX3RpbWUudmFsdWUgPSBuZXcgVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKTsKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCmluamVjdFJld2FyZHNfYm9vbF9mYWxzZUA1OgogICAgaW50Y18wIC8vIDAKICAgIGIgaW5qZWN0UmV3YXJkc19ib29sX21lcmdlQDYKCgovLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo6SW5qZWN0ZWRSZXdhcmRzUG9vbEZsdXhHYXRlZC5kZWxldGVBcHBsaWNhdGlvbigpIC0+IHZvaWQ6CmRlbGV0ZUFwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTMzCiAgICAvLyBhc3NlcnQob3AuVHhuLnNlbmRlciA9PT0gdGhpcy5hZG1pbl9hZGRyZXNzLnZhbHVlLCAiT25seSBhZG1pbiBjYW4gZGVsZXRlIGFwcGxpY2F0aW9uIik7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozOAogICAgLy8gYWRtaW5fYWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW5fYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxMzMKICAgIC8vIGFzc2VydChvcC5UeG4uc2VuZGVyID09PSB0aGlzLmFkbWluX2FkZHJlc3MudmFsdWUsICJPbmx5IGFkbWluIGNhbiBkZWxldGUgYXBwbGljYXRpb24iKTsKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gZGVsZXRlIGFwcGxpY2F0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMgogICAgLy8gdG90YWxfc3Rha2VkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ0b3RhbF9zdGFrZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTM0CiAgICAvLyBhc3NlcnQodGhpcy50b3RhbF9zdGFrZWQudmFsdWUubmF0aXZlID09PSAwLCAiU3Rha2VkIGFzc2V0cyBzdGlsbCBleGlzdCIpOwogICAgYnRvaQogICAgIQogICAgYXNzZXJ0IC8vIFN0YWtlZCBhc3NldHMgc3RpbGwgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEzNy0xNDUKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjgKICAgIC8vIHN0YWtlZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAic3Rha2VkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEzOQogICAgLy8geGZlckFzc2V0OiB0aGlzLnN0YWtlZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNDAKICAgIC8vIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNDIKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTQxCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjEzNy0xNDQKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIGludGNfMiAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MTYKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFOREFSRF9UWE5fRkVFOiB1aW50NjQgPSAxXzAwMDsKICAgIGludGNfMyAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTM3LTE0NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgeGZlckFzc2V0OiB0aGlzLnN0YWtlZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRDbG9zZVRvOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjgKICAgIC8vIHN0YWtlZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAic3Rha2VkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwCiAgICAvLyByZXdhcmRfYXNzZXRfaWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gInJld2FyZF9hc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNDcKICAgIC8vIGlmICh0aGlzLnN0YWtlZF9hc3NldF9pZC52YWx1ZSAhPT0gdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUpIHsKICAgICE9CiAgICBieiBkZWxldGVBcHBsaWNhdGlvbl9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE0OC0xNTYKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAKICAgIC8vIHJld2FyZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicmV3YXJkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE1MAogICAgLy8geGZlckFzc2V0OiB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNTEKICAgIC8vIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNTMKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTUyCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE0OC0xNTUKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0Q2xvc2VUbzogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIGludGNfMiAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MTYKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFOREFSRF9UWE5fRkVFOiB1aW50NjQgPSAxXzAwMDsKICAgIGludGNfMyAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTQ4LTE1NgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgeGZlckFzc2V0OiB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRDbG9zZVRvOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAoKZGVsZXRlQXBwbGljYXRpb25fYWZ0ZXJfaWZfZWxzZUA0OgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6OkluamVjdGVkUmV3YXJkc1Bvb2xGbHV4R2F0ZWQuc3Rha2Uoc3Rha2VUeG46IHVpbnQ2NCwgcXVhbnRpdHk6IHVpbnQ2NCwgbWJyVHhuOiB1aW50NjQpIC0+IHZvaWQ6CnN0YWtlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTYwLTE2MQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiIH0pCiAgICAvLyBzdGFrZShzdGFrZVR4bjogZ3R4bi5Bc3NldFRyYW5zZmVyVHhuLCBxdWFudGl0eTogdWludDY0LCBtYnJUeG46IGd0eG4uUGF5bWVudFR4bik6IHZvaWQgewogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNjIKICAgIC8vIGFzc2VydChxdWFudGl0eSA+IDAsICJJbnZhbGlkIHF1YW50aXR5Iik7CiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2VydCAvLyBJbnZhbGlkIHF1YW50aXR5CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNjQtMTY5CiAgICAvLyBhc3NlcnRNYXRjaChzdGFrZVR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IEFzc2V0KHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE2NQogICAgLy8gc2VuZGVyOiBvcC5UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTY0LTE2OQogICAgLy8gYXNzZXJ0TWF0Y2goc3Rha2VUeG4sIHsKICAgIC8vICAgc2VuZGVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBBc3NldCh0aGlzLnN0YWtlZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUpLAogICAgLy8gICBhc3NldEFtb3VudDogcXVhbnRpdHksCiAgICAvLyB9KTsKICAgID09CiAgICBieiBzdGFrZV9ib29sX2ZhbHNlQDUKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTY2CiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNjQtMTY5CiAgICAvLyBhc3NlcnRNYXRjaChzdGFrZVR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IEFzc2V0KHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgPT0KICAgIGJ6IHN0YWtlX2Jvb2xfZmFsc2VANQogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4CiAgICAvLyBzdGFrZWRfYXNzZXRfaWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gInN0YWtlZF9hc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNjcKICAgIC8vIHhmZXJBc3NldDogQXNzZXQodGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlKSwKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE2NC0xNjkKICAgIC8vIGFzc2VydE1hdGNoKHN0YWtlVHhuLCB7CiAgICAvLyAgIHNlbmRlcjogb3AuVHhuLnNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogQXNzZXQodGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlKSwKICAgIC8vICAgYXNzZXRBbW91bnQ6IHF1YW50aXR5LAogICAgLy8gfSk7CiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUA1CiAgICBmcmFtZV9kaWcgLTMKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBieiBzdGFrZV9ib29sX2ZhbHNlQDUKICAgIGludGNfMSAvLyAxCgpzdGFrZV9ib29sX21lcmdlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNjQtMTY5CiAgICAvLyBhc3NlcnRNYXRjaChzdGFrZVR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IEFzc2V0KHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSksCiAgICAvLyAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSwKICAgIC8vIH0pOwogICAgYXNzZXJ0IC8vIGFzc2VydCB0YXJnZXQgaXMgbWF0Y2ggZm9yIGNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE3MS0xNzUKICAgIC8vIGFzc2VydE1hdGNoKG1iclR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBCT1hfRkVFLAogICAgLy8gfSk7CiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTcyCiAgICAvLyBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNzEtMTc1CiAgICAvLyBhc3NlcnRNYXRjaChtYnJUeG4sIHsKICAgIC8vICAgc2VuZGVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogQk9YX0ZFRSwKICAgIC8vIH0pOwogICAgPT0KICAgIGJ6IHN0YWtlX2Jvb2xfZmFsc2VAMTAKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE3MwogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE3MS0xNzUKICAgIC8vIGFzc2VydE1hdGNoKG1iclR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBCT1hfRkVFLAogICAgLy8gfSk7CiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUAxMAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoxNwogICAgLy8gZXhwb3J0IGNvbnN0IEJPWF9GRUU6IHVpbnQ2NCA9IDIyXzUwMDsKICAgIHB1c2hpbnQgMjI1MDAgLy8gMjI1MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE3MS0xNzUKICAgIC8vIGFzc2VydE1hdGNoKG1iclR4biwgewogICAgLy8gICBzZW5kZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBCT1hfRkVFLAogICAgLy8gfSk7CiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUAxMAogICAgaW50Y18xIC8vIDEKCnN0YWtlX2Jvb2xfbWVyZ2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxNzEtMTc1CiAgICAvLyBhc3NlcnRNYXRjaChtYnJUeG4sIHsKICAgIC8vICAgc2VuZGVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogQk9YX0ZFRSwKICAgIC8vIH0pOwogICAgYXNzZXJ0IC8vIGFzc2VydCB0YXJnZXQgaXMgbWF0Y2ggZm9yIGNvbmRpdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjQ2CiAgICAvLyBmbHV4X29yYWNsZV9hcHAgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmx1eF9vcmFjbGVfYXBwIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE3OAogICAgLy8gY29uc3QgYWRkcmVzcyA9IG9yYWNsZS5hZGRyZXNzOwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE4Mi0xODkKICAgIC8vIGNvbnN0IHJlc3VsdCA9IGFiaUNhbGwoRmx1eEdhdGVTdHViLnByb3RvdHlwZS5nZXRVc2VyVGllciwgewogICAgLy8gICBhcHBJZDogY29udHJhY3RBcHBJZCwKICAgIC8vICAgYXJnczogW25ldyBhcmM0LkFkZHJlc3Mob3AuVHhuLnNlbmRlcildLAogICAgLy8gICBzZW5kZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIGFwcHM6IFtvcmFjbGVdLAogICAgLy8gICBhY2NvdW50czogW29wLlR4bi5zZW5kZXJdLAogICAgLy8gfSkucmV0dXJuVmFsdWU7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxODUKICAgIC8vIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTg4CiAgICAvLyBhY2NvdW50czogW29wLlR4bi5zZW5kZXJdLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTg0CiAgICAvLyBhcmdzOiBbbmV3IGFyYzQuQWRkcmVzcyhvcC5UeG4uc2VuZGVyKV0sCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE4Mi0xODkKICAgIC8vIGNvbnN0IHJlc3VsdCA9IGFiaUNhbGwoRmx1eEdhdGVTdHViLnByb3RvdHlwZS5nZXRVc2VyVGllciwgewogICAgLy8gICBhcHBJZDogY29udHJhY3RBcHBJZCwKICAgIC8vICAgYXJnczogW25ldyBhcmM0LkFkZHJlc3Mob3AuVHhuLnNlbmRlcildLAogICAgLy8gICBzZW5kZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIGFwcHM6IFtvcmFjbGVdLAogICAgLy8gICBhY2NvdW50czogW29wLlR4bi5zZW5kZXJdLAogICAgLy8gfSkucmV0dXJuVmFsdWU7CiAgICBwdXNoYnl0ZXMgMHhkNGQ3YWE1YyAvLyBtZXRob2QgImdldFVzZXJUaWVyKGFkZHJlc3MpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFjY291bnRzCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbnMKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MTYKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFOREFSRF9UWE5fRkVFOiB1aW50NjQgPSAxXzAwMDsKICAgIGludGNfMyAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTgyLTE4OQogICAgLy8gY29uc3QgcmVzdWx0ID0gYWJpQ2FsbChGbHV4R2F0ZVN0dWIucHJvdG90eXBlLmdldFVzZXJUaWVyLCB7CiAgICAvLyAgIGFwcElkOiBjb250cmFjdEFwcElkLAogICAgLy8gICBhcmdzOiBbbmV3IGFyYzQuQWRkcmVzcyhvcC5UeG4uc2VuZGVyKV0sCiAgICAvLyAgIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgYXBwczogW29yYWNsZV0sCiAgICAvLyAgIGFjY291bnRzOiBbb3AuVHhuLnNlbmRlcl0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZTsKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxOTEKICAgIC8vIGFzc2VydChyZXN1bHQubmF0aXZlID49IHRoaXMuZmx1eF90aWVyX3JlcXVpcmVkLnZhbHVlLm5hdGl2ZSwgIkluc3VmZmljaWVudCBmbHV4IHRpZXIiKTsKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjQ0CiAgICAvLyBmbHV4X3RpZXJfcmVxdWlyZWQgPSBHbG9iYWxTdGF0ZTxVaW50Tjg+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAiZmx1eF90aWVyX3JlcXVpcmVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE5MQogICAgLy8gYXNzZXJ0KHJlc3VsdC5uYXRpdmUgPj0gdGhpcy5mbHV4X3RpZXJfcmVxdWlyZWQudmFsdWUubmF0aXZlLCAiSW5zdWZmaWNpZW50IGZsdXggdGllciIpOwogICAgYnRvaQogICAgPj0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgZmx1eCB0aWVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxOTMKICAgIC8vIGNvbnN0IGhhc0xvYW4gPSB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikuZXhpc3RzOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTkzCiAgICAvLyBjb25zdCBoYXNMb2FuID0gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLmV4aXN0czsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTk1CiAgICAvLyBpZiAoaGFzTG9hbikgewogICAgYnogc3Rha2VfZWxzZV9ib2R5QDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyOAogICAgLy8gc3Rha2VkX2Fzc2V0X2lkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJzdGFrZWRfYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAKICAgIC8vIHJld2FyZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicmV3YXJkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE5NgogICAgLy8gaWYgKHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlID09PSB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZSkgewogICAgPT0KICAgIGJ6IHN0YWtlX2Vsc2VfYm9keUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzQKICAgIC8vIGN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiY3VycmVudF9hc2FfcmV3YXJkX2luZGV4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjE5OQogICAgLy8gdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUubmF0aXZlIC0gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLmxhc3RSZXdhcmRJbmRleC5uYXRpdmU7CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoxOTkKICAgIC8vIHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLm5hdGl2ZSAtIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZS5sYXN0UmV3YXJkSW5kZXgubmF0aXZlOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MTk5CiAgICAvLyB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZS5uYXRpdmUgLSB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUubGFzdFJld2FyZEluZGV4Lm5hdGl2ZTsKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBwdXNoaW50IDggLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBieXRlY18wIC8vICJzdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIwMAogICAgLy8gbGV0IHNoYXJlT2ZUb3RhbFN0YWtlID0gbXVsRGl2Vyh0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUuc3Rha2UubmF0aXZlLCBQUkVDSVNJT04sIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSk7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMDAKICAgIC8vIGxldCBzaGFyZU9mVG90YWxTdGFrZSA9IG11bERpdlcodGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLnN0YWtlLm5hdGl2ZSwgUFJFQ0lTSU9OLCB0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUpOwogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIwMAogICAgLy8gbGV0IHNoYXJlT2ZUb3RhbFN0YWtlID0gbXVsRGl2Vyh0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUuc3Rha2UubmF0aXZlLCBQUkVDSVNJT04sIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSk7CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjcKICAgIC8vIGNvbnN0IFtoaSwgbG9dID0gbXVsdyhhLCBiKTsKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czo0CiAgICAvLyBleHBvcnQgY29uc3QgUFJFQ0lTSU9OOiB1aW50NjQgPSAxXzAwMF8wMDBfMDAwXzAwMF8wMDA7CiAgICBpbnRjIDQgLy8gMTAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjI3CiAgICAvLyBjb25zdCBbaGksIGxvXSA9IG11bHcoYSwgYik7CiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjgKICAgIC8vIHJldHVybiBkaXZ3KGhpLCBsbywgYyk7CiAgICB1bmNvdmVyIDIKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoyNwogICAgLy8gY29uc3QgW2hpLCBsb10gPSBtdWx3KGEsIGIpOwogICAgbXVsdwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjQKICAgIC8vIGV4cG9ydCBjb25zdCBQUkVDSVNJT046IHVpbnQ2NCA9IDFfMDAwXzAwMF8wMDBfMDAwXzAwMDsKICAgIGludGMgNCAvLyAxMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjgKICAgIC8vIHJldHVybiBkaXZ3KGhpLCBsbywgYyk7CiAgICBkaXZ3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMDIKICAgIC8vIGNvbnN0IG5ld1N0YWtlID0gbmV3IFVpbnRONjQodGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLnN0YWtlLm5hdGl2ZSArIHN0YWtlVHhuLmFzc2V0QW1vdW50ICsgc2hhcmVPZlJld2FyZHMpOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjAyCiAgICAvLyBjb25zdCBuZXdTdGFrZSA9IG5ldyBVaW50TjY0KHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZS5zdGFrZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCArIHNoYXJlT2ZSZXdhcmRzKTsKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgIHN3YXAKICAgIGRpZyAxCiAgICArCiAgICBkaWcgMgogICAgKwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzQKICAgIC8vIGN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiY3VycmVudF9hc2FfcmV3YXJkX2luZGV4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIwMy0yMDYKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZSA9IG5ldyBTdGFrZUluZm9SZWNvcmQoewogICAgLy8gICBzdGFrZTogbmV3U3Rha2UsCiAgICAvLyAgIGxhc3RSZXdhcmRJbmRleDogdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUsCiAgICAvLyB9KS5jb3B5KCk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBieXRlY18wIC8vICJzdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIwMwogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMDMtMjA2CiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IG5ld1N0YWtlLAogICAgLy8gICBsYXN0UmV3YXJkSW5kZXg6IHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLAogICAgLy8gfSkuY29weSgpOwogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIwNwogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCArIHNoYXJlT2ZSZXdhcmRzKTsKICAgIGJ0b2kKICAgICsKICAgICsKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMyCiAgICAvLyB0b3RhbF9zdGFrZWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjA3CiAgICAvLyB0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSArIHN0YWtlVHhuLmFzc2V0QW1vdW50ICsgc2hhcmVPZlJld2FyZHMpOwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKc3Rha2VfZWxzZV9ib2R5QDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGJ5dGVjXzAgLy8gInN0IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjEwCiAgICAvLyBjb25zdCBuZXdTdGFrZSA9IG5ldyBVaW50TjY0KHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZS5zdGFrZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCk7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMTAKICAgIC8vIGNvbnN0IG5ld1N0YWtlID0gbmV3IFVpbnRONjQodGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLnN0YWtlLm5hdGl2ZSArIHN0YWtlVHhuLmFzc2V0QW1vdW50KTsKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgIHN3YXAKICAgIGRpZyAxCiAgICArCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMTMKICAgIC8vIGxhc3RSZXdhcmRJbmRleDogdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLmxhc3RSZXdhcmRJbmRleCwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIxMwogICAgLy8gbGFzdFJld2FyZEluZGV4OiB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUubGFzdFJld2FyZEluZGV4LAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjExLTIxNAogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICAvLyAgIHN0YWtlOiBuZXdTdGFrZSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUubGFzdFJld2FyZEluZGV4LAogICAgLy8gfSkuY29weSgpOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMTEKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZSA9IG5ldyBTdGFrZUluZm9SZWNvcmQoewogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjExLTIxNAogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICAvLyAgIHN0YWtlOiBuZXdTdGFrZSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUubGFzdFJld2FyZEluZGV4LAogICAgLy8gfSkuY29weSgpOwogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIxNQogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCk7CiAgICBidG9pCiAgICArCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMgogICAgLy8gdG90YWxfc3Rha2VkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjXzIgLy8gInRvdGFsX3N0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIxNQogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpzdGFrZV9lbHNlX2JvZHlAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMTkKICAgIC8vIHN0YWtlOiBuZXcgVWludE42NChzdGFrZVR4bi5hc3NldEFtb3VudCksCiAgICBmcmFtZV9kaWcgLTMKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMTgtMjIxCiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IG5ldyBVaW50TjY0KHN0YWtlVHhuLmFzc2V0QW1vdW50KSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSwKICAgIC8vIH0pLmNvcHkoKTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGJ5dGVjXzAgLy8gInN0IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjE4CiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIxOC0yMjEKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZSA9IG5ldyBTdGFrZUluZm9SZWNvcmQoewogICAgLy8gICBzdGFrZTogbmV3IFVpbnRONjQoc3Rha2VUeG4uYXNzZXRBbW91bnQpLAogICAgLy8gICBsYXN0UmV3YXJkSW5kZXg6IHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLAogICAgLy8gfSkuY29weSgpOwogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NDAKICAgIC8vIG51bV9zdGFrZXJzID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJudW1fc3Rha2VycyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMjMKICAgIC8vIHRoaXMubnVtX3N0YWtlcnMudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLm51bV9zdGFrZXJzLnZhbHVlLm5hdGl2ZSArIDEpOwogICAgYnRvaQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjQwCiAgICAvLyBudW1fc3Rha2VycyA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBieXRlYyA2IC8vICJudW1fc3Rha2VycyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIyMwogICAgLy8gdGhpcy5udW1fc3Rha2Vycy52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMubnVtX3N0YWtlcnMudmFsdWUubmF0aXZlICsgMSk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIyNAogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCk7CiAgICBidG9pCiAgICArCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMgogICAgLy8gdG90YWxfc3Rha2VkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjXzIgLy8gInRvdGFsX3N0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIyNAogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgKyBzdGFrZVR4bi5hc3NldEFtb3VudCk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpzdGFrZV9ib29sX2ZhbHNlQDEwOgogICAgaW50Y18wIC8vIDAKICAgIGIgc3Rha2VfYm9vbF9tZXJnZUAxMQoKc3Rha2VfYm9vbF9mYWxzZUA1OgogICAgaW50Y18wIC8vIDAKICAgIGIgc3Rha2VfYm9vbF9tZXJnZUA2CgoKLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6OkluamVjdGVkUmV3YXJkc1Bvb2xGbHV4R2F0ZWQuY2xhaW1SZXdhcmRzKCkgLT4gdm9pZDoKY2xhaW1SZXdhcmRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjI4LTIyOQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogIk5vT3AiIH0pCiAgICAvLyBjbGFpbVJld2FyZHMoKTogdm9pZCB7CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBieXRlY18wIC8vICJzdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIzMAogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS5leGlzdHMsICJObyBzdGFrZSBmb3VuZCBmb3IgdXNlciIpOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjMwCiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLmV4aXN0cywgIk5vIHN0YWtlIGZvdW5kIGZvciB1c2VyIik7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBObyBzdGFrZSBmb3VuZCBmb3IgdXNlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGJ5dGVjXzAgLy8gInN0IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjMyCiAgICAvLyBjb25zdCBzdGFrZXIgPSB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUuY29weSgpOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjMyCiAgICAvLyBjb25zdCBzdGFrZXIgPSB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUuY29weSgpOwogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIzNAogICAgLy8gYXNzZXJ0KHN0YWtlci5zdGFrZS5uYXRpdmUgPiAwLCAiTm8gc3Rha2UiKTsKICAgIGR1cAogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBhc3NlcnQgLy8gTm8gc3Rha2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyMzcKICAgIC8vIGNvbnN0IHJld2FyZEluZGV4RGlmZjogdWludDY0ID0gdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUubmF0aXZlIC0gc3Rha2VyLmxhc3RSZXdhcmRJbmRleC5uYXRpdmU7CiAgICBidG9pCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjIzOAogICAgLy8gbGV0IHNoYXJlT2ZUb3RhbFN0YWtlID0gbXVsRGl2VyhzdGFrZXIuc3Rha2UubmF0aXZlLCBQUkVDSVNJT04sIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSk7CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjcKICAgIC8vIGNvbnN0IFtoaSwgbG9dID0gbXVsdyhhLCBiKTsKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjQKICAgIC8vIGV4cG9ydCBjb25zdCBQUkVDSVNJT046IHVpbnQ2NCA9IDFfMDAwXzAwMF8wMDBfMDAwXzAwMDsKICAgIGludGMgNCAvLyAxMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjcKICAgIC8vIGNvbnN0IFtoaSwgbG9dID0gbXVsdyhhLCBiKTsKICAgIG11bHcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoyOAogICAgLy8gcmV0dXJuIGRpdncoaGksIGxvLCBjKTsKICAgIHVuY292ZXIgMgogICAgZGl2dwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjI3CiAgICAvLyBjb25zdCBbaGksIGxvXSA9IG11bHcoYSwgYik7CiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6NAogICAgLy8gZXhwb3J0IGNvbnN0IFBSRUNJU0lPTjogdWludDY0ID0gMV8wMDBfMDAwXzAwMF8wMDBfMDAwOwogICAgaW50YyA0IC8vIDEwMDAwMDAwMDAwMDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoyOAogICAgLy8gcmV0dXJuIGRpdncoaGksIGxvLCBjKTsKICAgIGRpdncKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjQxCiAgICAvLyBpZiAoc2hhcmVPZlJld2FyZHMgPiAwKSB7CiAgICBieiBjbGFpbVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozNAogICAgLy8gY3VycmVudF9hc2FfcmV3YXJkX2luZGV4ID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjQzCiAgICAvLyB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLm5hdGl2ZSAtIHNoYXJlT2ZSZXdhcmRzKTsKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC0KICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWNfMSAvLyAiY3VycmVudF9hc2FfcmV3YXJkX2luZGV4IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjQzCiAgICAvLyB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLm5hdGl2ZSAtIHNoYXJlT2ZSZXdhcmRzKTsKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNDUtMjUzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRoaXMucmV3YXJkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICAgIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHNoYXJlT2ZSZXdhcmRzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAKICAgIC8vIHJld2FyZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicmV3YXJkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI0NwogICAgLy8geGZlckFzc2V0OiB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNDgKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNDkKICAgIC8vIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjQ1LTI1MgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgeGZlckFzc2V0OiB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogb3AuVHhuLnNlbmRlciwKICAgIC8vICAgICBzZW5kZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBzaGFyZU9mUmV3YXJkcywKICAgIC8vICAgICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIH0pCiAgICBpbnRjXzIgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjE2CiAgICAvLyBleHBvcnQgY29uc3QgU1RBTkRBUkRfVFhOX0ZFRTogdWludDY0ID0gMV8wMDA7CiAgICBpbnRjXzMgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI0NS0yNTMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgICAgc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogc2hhcmVPZlJld2FyZHMsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAoKY2xhaW1SZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNTUtMjU4CiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IHN0YWtlci5zdGFrZSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSwKICAgIC8vIH0pLmNvcHkoKTsKICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBieXRlY18wIC8vICJzdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI1NQogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNTUtMjU4CiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IHN0YWtlci5zdGFrZSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSwKICAgIC8vIH0pLmNvcHkoKTsKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjpJbmplY3RlZFJld2FyZHNQb29sRmx1eEdhdGVkLnVuc3Rha2UocXVhbnRpdHk6IHVpbnQ2NCkgLT4gdm9pZDoKdW5zdGFrZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2MS0yNjIKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICJOb09wIiB9KQogICAgLy8gdW5zdGFrZShxdWFudGl0eTogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDIKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNjMKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikuZXhpc3RzLCAiTm8gc3Rha2UgZm91bmQgZm9yIHVzZXIiKTsKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2MwogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS5leGlzdHMsICJObyBzdGFrZSBmb3VuZCBmb3IgdXNlciIpOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm8gc3Rha2UgZm91bmQgZm9yIHVzZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBieXRlY18wIC8vICJzdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2NAogICAgLy8gY29uc3QgY3VycmVudFJlY29yZCA9IHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZS5jb3B5KCk7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNjQKICAgIC8vIGNvbnN0IGN1cnJlbnRSZWNvcmQgPSB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUuY29weSgpOwogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNjUKICAgIC8vIGFzc2VydChjdXJyZW50UmVjb3JkLnN0YWtlLm5hdGl2ZSA+IDAsICJObyBzdGFrZSIpOwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBhc3NlcnQgLy8gTm8gc3Rha2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2NwogICAgLy8gYXNzZXJ0KGN1cnJlbnRSZWNvcmQuc3Rha2UubmF0aXZlID49IHF1YW50aXR5KTsKICAgIGZyYW1lX2RpZyAtMQogICAgPj0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjcyCiAgICAvLyBpZiAoY3VycmVudFJlY29yZC5sYXN0UmV3YXJkSW5kZXggIT09IHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlKSB7CiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNzIKICAgIC8vIGlmIChjdXJyZW50UmVjb3JkLmxhc3RSZXdhcmRJbmRleCAhPT0gdGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUpIHsKICAgICE9CiAgICBieiB1bnN0YWtlX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzQKICAgIC8vIGN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiY3VycmVudF9hc2FfcmV3YXJkX2luZGV4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI3NAogICAgLy8gY29uc3QgcmV3YXJkSW5kZXhEaWZmOiB1aW50NjQgPSB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZS5uYXRpdmUgLSBjdXJyZW50UmVjb3JkLmxhc3RSZXdhcmRJbmRleC5uYXRpdmU7CiAgICBidG9pCiAgICBmcmFtZV9kaWcgNgogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMgogICAgLy8gdG90YWxfc3Rha2VkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ0b3RhbF9zdGFrZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6Mjc1CiAgICAvLyBsZXQgc2hhcmVPZlRvdGFsU3Rha2UgPSBtdWxEaXZXKGN1cnJlbnRSZWNvcmQuc3Rha2UubmF0aXZlLCBQUkVDSVNJT04sIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSk7CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjcKICAgIC8vIGNvbnN0IFtoaSwgbG9dID0gbXVsdyhhLCBiKTsKICAgIGZyYW1lX2RpZyA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6NAogICAgLy8gZXhwb3J0IGNvbnN0IFBSRUNJU0lPTjogdWludDY0ID0gMV8wMDBfMDAwXzAwMF8wMDBfMDAwOwogICAgaW50YyA0IC8vIDEwMDAwMDAwMDAwMDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoyNwogICAgLy8gY29uc3QgW2hpLCBsb10gPSBtdWx3KGEsIGIpOwogICAgbXVsdwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjI4CiAgICAvLyByZXR1cm4gZGl2dyhoaSwgbG8sIGMpOwogICAgdW5jb3ZlciAyCiAgICBkaXZ3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MjcKICAgIC8vIGNvbnN0IFtoaSwgbG9dID0gbXVsdyhhLCBiKTsKICAgIG11bHcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czo0CiAgICAvLyBleHBvcnQgY29uc3QgUFJFQ0lTSU9OOiB1aW50NjQgPSAxXzAwMF8wMDBfMDAwXzAwMF8wMDA7CiAgICBpbnRjIDQgLy8gMTAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2NvbmZpZy5hbGdvLnRzOjI4CiAgICAvLyByZXR1cm4gZGl2dyhoaSwgbG8sIGMpOwogICAgZGl2dwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI3OAogICAgLy8gaWYgKHNoYXJlT2ZSZXdhcmRzID4gMCkgewogICAgYnogdW5zdGFrZV9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNzkKICAgIC8vIHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlID0gbmV3IFVpbnRONjQodGhpcy5jdXJyZW50X2FzYV9yZXdhcmRfaW5kZXgudmFsdWUubmF0aXZlIC0gc2hhcmVPZlJld2FyZHMpOwogICAgYnRvaQogICAgZnJhbWVfZGlnIDQKICAgIC0KICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgYnl0ZWNfMSAvLyAiY3VycmVudF9hc2FfcmV3YXJkX2luZGV4IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6Mjc5CiAgICAvLyB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLm5hdGl2ZSAtIHNoYXJlT2ZSZXdhcmRzKTsKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyOAogICAgLy8gc3Rha2VkX2Fzc2V0X2lkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJzdGFrZWRfYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAKICAgIC8vIHJld2FyZF9hc3NldF9pZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicmV3YXJkX2Fzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4MQogICAgLy8gaWYgKHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlID09PSB0aGlzLnJld2FyZF9hc3NldF9pZC52YWx1ZSkgewogICAgPT0KICAgIGJ6IHVuc3Rha2VfZWxzZV9ib2R5QDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4NAogICAgLy8gc3Rha2U6IG5ldyBVaW50TjY0KGN1cnJlbnRSZWNvcmQuc3Rha2UubmF0aXZlICsgc2hhcmVPZlJld2FyZHMpLAogICAgZnJhbWVfZGlnIDcKICAgIGZyYW1lX2RpZyA0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgICsKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyODMtMjg2CiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IG5ldyBVaW50TjY0KGN1cnJlbnRSZWNvcmQuc3Rha2UubmF0aXZlICsgc2hhcmVPZlJld2FyZHMpLAogICAgLy8gICBsYXN0UmV3YXJkSW5kZXg6IHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLAogICAgLy8gfSkuY29weSgpOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyODMKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZSA9IG5ldyBTdGFrZUluZm9SZWNvcmQoewogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjgzLTI4NgogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICAvLyAgIHN0YWtlOiBuZXcgVWludE42NChjdXJyZW50UmVjb3JkLnN0YWtlLm5hdGl2ZSArIHNoYXJlT2ZSZXdhcmRzKSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSwKICAgIC8vIH0pLmNvcHkoKTsKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMyCiAgICAvLyB0b3RhbF9zdGFrZWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInRvdGFsX3N0YWtlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyODcKICAgIC8vIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlID0gbmV3IFVpbnRONjQodGhpcy50b3RhbF9zdGFrZWQudmFsdWUubmF0aXZlICsgc2hhcmVPZlJld2FyZHMpOwogICAgYnRvaQogICAgKwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBieXRlY18yIC8vICJ0b3RhbF9zdGFrZWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyODcKICAgIC8vIHRoaXMudG90YWxfc3Rha2VkLnZhbHVlID0gbmV3IFVpbnRONjQodGhpcy50b3RhbF9zdGFrZWQudmFsdWUubmF0aXZlICsgc2hhcmVPZlJld2FyZHMpOwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCnVuc3Rha2VfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGJ5dGVjXzAgLy8gInN0IgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAyCiAgICAvLyBjb25zdCB1cGRhdGVkUmVjb3JkID0gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlLmNvcHkoKTsKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwMgogICAgLy8gY29uc3QgdXBkYXRlZFJlY29yZCA9IHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZS5jb3B5KCk7CiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMDMtMzExCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRoaXMuc3Rha2VkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICAgIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHF1YW50aXR5ID09PSAwID8gdXBkYXRlZFJlY29yZC5zdGFrZS5uYXRpdmUgOiBxdWFudGl0eSwKICAgIC8vICAgICBmZWU6IFNUQU5EQVJEX1RYTl9GRUUsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4CiAgICAvLyBzdGFrZWRfYXNzZXRfaWQgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gInN0YWtlZF9hc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMDUKICAgIC8vIHhmZXJBc3NldDogdGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgYnRvaQogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMDYKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwNwogICAgLy8gc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwOAogICAgLy8gYXNzZXRBbW91bnQ6IHF1YW50aXR5ID09PSAwID8gdXBkYXRlZFJlY29yZC5zdGFrZS5uYXRpdmUgOiBxdWFudGl0eSwKICAgIGZyYW1lX2RpZyAtMQogICAgYm56IHVuc3Rha2VfdGVybmFyeV9mYWxzZUAxMAogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAoKdW5zdGFrZV90ZXJuYXJ5X21lcmdlQDExOgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMwMy0zMTAKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5zdGFrZWRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgICAgc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogcXVhbnRpdHkgPT09IDAgPyB1cGRhdGVkUmVjb3JkLnN0YWtlLm5hdGl2ZSA6IHF1YW50aXR5LAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIGludGNfMiAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvY29uZmlnLmFsZ28udHM6MTYKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFOREFSRF9UWE5fRkVFOiB1aW50NjQgPSAxXzAwMDsKICAgIGludGNfMyAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzAzLTMxMQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgeGZlckFzc2V0OiB0aGlzLnN0YWtlZF9hc3NldF9pZC52YWx1ZS5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogb3AuVHhuLnNlbmRlciwKICAgIC8vICAgICBzZW5kZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBxdWFudGl0eSA9PT0gMCA/IHVwZGF0ZWRSZWNvcmQuc3Rha2UubmF0aXZlIDogcXVhbnRpdHksCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIKICAgIC8vIHRvdGFsX3N0YWtlZCA9IEdsb2JhbFN0YXRlPFVpbnRONjQ+KCk7CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidG90YWxfc3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMxNQogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgLSAocXVhbnRpdHkgPT09IDAgPyB1cGRhdGVkUmVjb3JkLnN0YWtlLm5hdGl2ZSA6IHF1YW50aXR5KSk7CiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2RpZyAtMQogICAgYm56IHVuc3Rha2VfdGVybmFyeV9mYWxzZUAxNAogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAoKdW5zdGFrZV90ZXJuYXJ5X21lcmdlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzE1CiAgICAvLyB0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMudG90YWxfc3Rha2VkLnZhbHVlLm5hdGl2ZSAtIChxdWFudGl0eSA9PT0gMCA/IHVwZGF0ZWRSZWNvcmQuc3Rha2UubmF0aXZlIDogcXVhbnRpdHkpKTsKICAgIGZyYW1lX2RpZyA1CiAgICBzd2FwCiAgICAtCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMgogICAgLy8gdG90YWxfc3Rha2VkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjXzIgLy8gInRvdGFsX3N0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMxNQogICAgLy8gdGhpcy50b3RhbF9zdGFrZWQudmFsdWUgPSBuZXcgVWludE42NCh0aGlzLnRvdGFsX3N0YWtlZC52YWx1ZS5uYXRpdmUgLSAocXVhbnRpdHkgPT09IDAgPyB1cGRhdGVkUmVjb3JkLnN0YWtlLm5hdGl2ZSA6IHF1YW50aXR5KSk7CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzE2CiAgICAvLyBpZiAocXVhbnRpdHkgPT09IDApIHsKICAgIGZyYW1lX2RpZyAtMQogICAgYm56IHVuc3Rha2VfZWxzZV9ib2R5QDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMTcKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS5kZWxldGUoKTsKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI2CiAgICAvLyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFN0YWtlSW5mb1JlY29yZD4oeyBrZXlQcmVmaXg6ICJzdCIgfSk7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMxNwogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLmRlbGV0ZSgpOwogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czo0MAogICAgLy8gbnVtX3N0YWtlcnMgPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIm51bV9zdGFrZXJzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjMxOAogICAgLy8gdGhpcy5udW1fc3Rha2Vycy52YWx1ZSA9IG5ldyBVaW50TjY0KHRoaXMubnVtX3N0YWtlcnMudmFsdWUubmF0aXZlIC0gMSk7CiAgICBidG9pCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6NDAKICAgIC8vIG51bV9zdGFrZXJzID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGJ5dGVjIDYgLy8gIm51bV9zdGFrZXJzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzE4CiAgICAvLyB0aGlzLm51bV9zdGFrZXJzLnZhbHVlID0gbmV3IFVpbnRONjQodGhpcy5udW1fc3Rha2Vycy52YWx1ZS5uYXRpdmUgLSAxKTsKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnVuc3Rha2VfZWxzZV9ib2R5QDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIxCiAgICAvLyBzdGFrZTogbmV3IFVpbnRONjQodXBkYXRlZFJlY29yZC5zdGFrZS5uYXRpdmUgLSBxdWFudGl0eSksCiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgLTEKICAgIC0KICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjM0CiAgICAvLyBjdXJyZW50X2FzYV9yZXdhcmRfaW5kZXggPSBHbG9iYWxTdGF0ZTxVaW50TjY0PigpOwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMjAtMzIzCiAgICAvLyB0aGlzLnN0YWtlcnMob3AuVHhuLnNlbmRlcikudmFsdWUgPSBuZXcgU3Rha2VJbmZvUmVjb3JkKHsKICAgIC8vICAgc3Rha2U6IG5ldyBVaW50TjY0KHVwZGF0ZWRSZWNvcmQuc3Rha2UubmF0aXZlIC0gcXVhbnRpdHkpLAogICAgLy8gICBsYXN0UmV3YXJkSW5kZXg6IHRoaXMuY3VycmVudF9hc2FfcmV3YXJkX2luZGV4LnZhbHVlLAogICAgLy8gfSkuY29weSgpOwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyNgogICAgLy8gc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBTdGFrZUluZm9SZWNvcmQ+KHsga2V5UHJlZml4OiAic3QiIH0pOwogICAgYnl0ZWNfMCAvLyAic3QiCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMjAKICAgIC8vIHRoaXMuc3Rha2VycyhvcC5UeG4uc2VuZGVyKS52YWx1ZSA9IG5ldyBTdGFrZUluZm9SZWNvcmQoewogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjYKICAgIC8vIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgU3Rha2VJbmZvUmVjb3JkPih7IGtleVByZWZpeDogInN0IiB9KTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MzIwLTMyMwogICAgLy8gdGhpcy5zdGFrZXJzKG9wLlR4bi5zZW5kZXIpLnZhbHVlID0gbmV3IFN0YWtlSW5mb1JlY29yZCh7CiAgICAvLyAgIHN0YWtlOiBuZXcgVWludE42NCh1cGRhdGVkUmVjb3JkLnN0YWtlLm5hdGl2ZSAtIHF1YW50aXR5KSwKICAgIC8vICAgbGFzdFJld2FyZEluZGV4OiB0aGlzLmN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleC52YWx1ZSwKICAgIC8vIH0pLmNvcHkoKTsKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1YgoKdW5zdGFrZV90ZXJuYXJ5X2ZhbHNlQDE0OgogICAgZnJhbWVfZGlnIC0xCiAgICBiIHVuc3Rha2VfdGVybmFyeV9tZXJnZUAxNQoKdW5zdGFrZV90ZXJuYXJ5X2ZhbHNlQDEwOgogICAgZnJhbWVfZGlnIC0xCiAgICBiIHVuc3Rha2VfdGVybmFyeV9tZXJnZUAxMQoKdW5zdGFrZV9lbHNlX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4OS0yOTcKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgICAgc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogc2hhcmVPZlJld2FyZHMsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czozMAogICAgLy8gcmV3YXJkX2Fzc2V0X2lkID0gR2xvYmFsU3RhdGU8VWludE42ND4oKTsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJyZXdhcmRfYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2luamVjdGVkX3Jld2FyZHNfcG9vbF9mbHV4X2dhdGVkL2lycGZnLmFsZ28udHM6MjkxCiAgICAvLyB4ZmVyQXNzZXQ6IHRoaXMucmV3YXJkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSwKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI5MgogICAgLy8gYXNzZXRSZWNlaXZlcjogb3AuVHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI5MwogICAgLy8gc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgNAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9pcnBmZy5hbGdvLnRzOjI4OS0yOTYKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHhmZXJBc3NldDogdGhpcy5yZXdhcmRfYXNzZXRfaWQudmFsdWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IG9wLlR4bi5zZW5kZXIsCiAgICAvLyAgICAgc2VuZGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogc2hhcmVPZlJld2FyZHMsCiAgICAvLyAgICAgZmVlOiBTVEFOREFSRF9UWE5fRkVFLAogICAgLy8gICB9KQogICAgaW50Y18yIC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9pbmplY3RlZF9yZXdhcmRzX3Bvb2xfZmx1eF9nYXRlZC9jb25maWcuYWxnby50czoxNgogICAgLy8gZXhwb3J0IGNvbnN0IFNUQU5EQVJEX1RYTl9GRUU6IHVpbnQ2NCA9IDFfMDAwOwogICAgaW50Y18zIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvaW5qZWN0ZWRfcmV3YXJkc19wb29sX2ZsdXhfZ2F0ZWQvaXJwZmcuYWxnby50czoyODktMjk3CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRoaXMucmV3YXJkX2Fzc2V0X2lkLnZhbHVlLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBvcC5UeG4uc2VuZGVyLAogICAgLy8gICAgIHNlbmRlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHNoYXJlT2ZSZXdhcmRzLAogICAgLy8gICAgIGZlZTogU1RBTkRBUkRfVFhOX0ZFRSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKICAgIGIgdW5zdGFrZV9hZnRlcl9pZl9lbHNlQDgK","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CyAFAAEE6AeAgJqm6q/jASYLAnN0GGN1cnJlbnRfYXNhX3Jld2FyZF9pbmRleAx0b3RhbF9zdGFrZWQNYWRtaW5fYWRkcmVzcw9zdGFrZWRfYXNzZXRfaWQPcmV3YXJkX2Fzc2V0X2lkC251bV9zdGFrZXJzCAAAAAAAAAAAGmxhc3RfcmV3YXJkX2luamVjdGlvbl90aW1lEmZsdXhfdGllcl9yZXF1aXJlZA9mbHV4X29yYWNsZV9hcHAxG0EARoIJBNMkvqQElCAgZAQy23ptBDRwB+sEJIfDLAR6nuGJBKWua9EEgTzomgQxcsqdNhoAjgkAsgCKAHgAWgBMACcAGwALAAIiQzEZFEQxGEQjQzEZFEQxGEQ2GgEXiAPmI0MxGRREMRhEiANlI0MxGRREMRhEMRaBAglJOBAkEkQ2GgEXMRYjCUk4ECMSRIgB2yNDMRmBBRJEMRhEiAF5I0MxGRREMRhEMRYjCUk4ECQSRDYaARc2GgIXiAEMI0MxGRREMRhENhoBF8AciADqI0MxGRREMRhENhoBFzYaAhcxFiMJSTgQIxJENhoDFzYaBBfAMogANyNDMRkURDEYFEQ2GgGIAAIjQ4oBACuL/2eCAhBjb250cmFjdF92ZXJzaW9uCAAAAAAAAA+gZ4mKBQAxACIrZUQSRIv7FicETGeL/BYnBUxnKicHZycIJwdnKScHZycGJwdni/4WSZOBCA5EVwcBJwlMZycKi/9ni/04BzIKEkEAPYv9OAiBgLUYEkEAMSNEsTIKIrISshSL+7IRJLIQJbIBs4v8i/sTQQATsTIKIrISshSL/LIRJLIQJbIBs4kiQv/MigEAMQAiK2VEEkQri/9niYoDADEAIitlRBJEi/04ACIrZUQSQQA0i/04FDIKEkEAKov9OBGL/xJBACCL/TgSi/4SQQAWI0QiKWVEF4v+CBYpTGcyBxYnCExniSJC/+cxACIrZUQSRCIqZUQXFESxIicEZUQXMgMyCrIUIrISshWyESSyECWyAbMiJwRlRCInBWVEE0EAG7EiJwVlRBcyAzIKshQishKyFbIRJLIQJbIBs4mKAwCL/kSL/TgAMQASQQFRi/04FDIKEkEBR4v9OBEiJwRlRBcSQQE5i/04Eov+EkEBLyNEi/84ADEAEkEBH4v/OAcyChJBARWL/zgIgeSvARJBAQkjRCInCmVESXIIRQFEsTIKMQBJgATU16pcshqyGrIcSwGyMrIAshiBBrIQJbIBs7Q+SVcEAExXAASABBUffHUSRBciJwllRBcPRCgxAFC9RQFBAIwiJwRlRCInBWVEEkEAUiIpZUQXKDEAUL5EgQhbCSgxAFC+RCJbIiplRBdMIQQdTwKXHSEElygxAFC+RCJbi/04EkxLAQhLAggWIillRFAoMQBQTL8iKmVEFwgIFipMZ4koMQBQvkQiW4v9OBJMSwEIFigxAFC+RFcICFAoMQBQTL8iKmVEFwgWKkxniYv9OBJJFiIpZURQKDEAUEy/IicGZUQXIwgWJwZMZyIqZUQXCBYqTGeJIkL+9CJC/s6KAAAoMQBQvUUBRCgxAFC+RElXAAhMSSJbSUQiKWVEF08CgQhbCSIqZUQXTwIhBB1PApcdIQSXSUEAKyIpZUQXiwFJTgIJFilMZ7EiJwVlRBcxADIKTwOyErIAshSyESSyECWyAbMiKWVEiwBMUCgxAFBMv4mKAQAiRwKAAEcCKDEAUL1FAUQoMQBQvkxJTwJESSJbSU4CSUSL/w9EVwgIIillRBNBAFoiKWVEF4sGgQhbCSIqZUQXiwchBB1PApcdIQSXSYwEQQA4IillRBeLBAkWKUxnIicEZUQiJwVlRBJBAKWLB4sESU4CCBYiKWVEUCgxAFBMvyIqZUQXCBYqTGcoMQBQvkyMAkSxIicEZUQXjAMxAIwAMgqMAYv/QABjiwIiW7ISiwGyAIsAshSLA7IRJLIQJbIBsyIqZUQXjAWL/0AAOYsCIluLBUwJFipMZ4v/QAAUKDEAULxIIicGZUQXIwkWJwZMZ4mLAiJbi/8JFiIpZURQKDEAUEy/iYv/Qv/Gi/9C/5yxIicFZUQXMQAyCosEshKyALIUshEkshAlsgGzQv9a","clear":"C4EBQw=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type StakeInfoRecord = {
  stake: bigint,
  lastRewardIndex: bigint
}


/**
 * Converts the ABI tuple representation of a StakeInfoRecord to the struct representation
 */
export function StakeInfoRecordFromTuple(abiTuple: [bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakeInfoRecord, APP_SPEC.structs) as StakeInfoRecord
}

/**
 * The argument types for the Irpfg contract
 */
export type IrpfgArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'createApplication(address)void': {
      adminAddress: string
    }
    'initApplication(uint64,uint64,pay,uint64,application)void': {
      /**
       * - The asset ID of the token to be staked in the pool.
       */
      stakedAssetId: bigint | number
      /**
       * - The asset ID of the token to be distributed as rewards.
       */
      rewardAssetId: bigint | number
      /**
       * - The payment transaction providing the initial minimum balance for the contract.
       */
      initialBalanceTxn: AppMethodCallTransactionArgument
      fluxTierRequired: bigint | number
      fluxOracleApp: bigint
    }
    'updateAdminAddress(account)void': {
      adminAddress: Uint8Array | string
    }
    'injectRewards(axfer,uint64,uint64)void': {
      rewardTxn: AppMethodCallTransactionArgument
      quantity: bigint | number
      rewardAssetId: bigint | number
    }
    'deleteApplication()void': Record<string, never>
    'stake(axfer,uint64,pay)void': {
      stakeTxn: AppMethodCallTransactionArgument
      quantity: bigint | number
      mbrTxn: AppMethodCallTransactionArgument
    }
    'claimRewards()void': Record<string, never>
    'unstake(uint64)void': {
      quantity: bigint | number
    }
    'gas()void': Record<string, never>
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'createApplication(address)void': [adminAddress: string]
    'initApplication(uint64,uint64,pay,uint64,application)void': [stakedAssetId: bigint | number, rewardAssetId: bigint | number, initialBalanceTxn: AppMethodCallTransactionArgument, fluxTierRequired: bigint | number, fluxOracleApp: bigint]
    'updateAdminAddress(account)void': [adminAddress: Uint8Array | string]
    'injectRewards(axfer,uint64,uint64)void': [rewardTxn: AppMethodCallTransactionArgument, quantity: bigint | number, rewardAssetId: bigint | number]
    'deleteApplication()void': []
    'stake(axfer,uint64,pay)void': [stakeTxn: AppMethodCallTransactionArgument, quantity: bigint | number, mbrTxn: AppMethodCallTransactionArgument]
    'claimRewards()void': []
    'unstake(uint64)void': [quantity: bigint | number]
    'gas()void': []
  }
}

/**
 * The return type for each method
 */
export type IrpfgReturns = {
  'createApplication(address)void': void
  'initApplication(uint64,uint64,pay,uint64,application)void': void
  'updateAdminAddress(account)void': void
  'injectRewards(axfer,uint64,uint64)void': void
  'deleteApplication()void': void
  'stake(axfer,uint64,pay)void': void
  'claimRewards()void': void
  'unstake(uint64)void': void
  'gas()void': void
}

/**
 * Defines the types of available calls and state of the Irpfg smart contract.
 */
export type IrpfgTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(address)void' | 'createApplication', {
      argsObj: IrpfgArgs['obj']['createApplication(address)void']
      argsTuple: IrpfgArgs['tuple']['createApplication(address)void']
      returns: IrpfgReturns['createApplication(address)void']
    }>
    & Record<'initApplication(uint64,uint64,pay,uint64,application)void' | 'initApplication', {
      argsObj: IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void']
      argsTuple: IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']
      returns: IrpfgReturns['initApplication(uint64,uint64,pay,uint64,application)void']
    }>
    & Record<'updateAdminAddress(account)void' | 'updateAdminAddress', {
      argsObj: IrpfgArgs['obj']['updateAdminAddress(account)void']
      argsTuple: IrpfgArgs['tuple']['updateAdminAddress(account)void']
      returns: IrpfgReturns['updateAdminAddress(account)void']
    }>
    & Record<'injectRewards(axfer,uint64,uint64)void' | 'injectRewards', {
      argsObj: IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void']
      argsTuple: IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']
      returns: IrpfgReturns['injectRewards(axfer,uint64,uint64)void']
    }>
    & Record<'deleteApplication()void' | 'deleteApplication', {
      argsObj: IrpfgArgs['obj']['deleteApplication()void']
      argsTuple: IrpfgArgs['tuple']['deleteApplication()void']
      returns: IrpfgReturns['deleteApplication()void']
    }>
    & Record<'stake(axfer,uint64,pay)void' | 'stake', {
      argsObj: IrpfgArgs['obj']['stake(axfer,uint64,pay)void']
      argsTuple: IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']
      returns: IrpfgReturns['stake(axfer,uint64,pay)void']
    }>
    & Record<'claimRewards()void' | 'claimRewards', {
      argsObj: IrpfgArgs['obj']['claimRewards()void']
      argsTuple: IrpfgArgs['tuple']['claimRewards()void']
      returns: IrpfgReturns['claimRewards()void']
    }>
    & Record<'unstake(uint64)void' | 'unstake', {
      argsObj: IrpfgArgs['obj']['unstake(uint64)void']
      argsTuple: IrpfgArgs['tuple']['unstake(uint64)void']
      returns: IrpfgReturns['unstake(uint64)void']
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: IrpfgArgs['obj']['gas()void']
      argsTuple: IrpfgArgs['tuple']['gas()void']
      returns: IrpfgReturns['gas()void']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        stakedAssetId: bigint
        rewardAssetId: bigint
        totalStaked: bigint
        currentAsaRewardIndex: bigint
        lastRewardInjectionTime: bigint
        adminAddress: string
        numStakers: bigint
        contractVersion: bigint
        fluxTierRequired: number
        fluxOracleApp: bigint
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        stakers: Map<string, StakeInfoRecord>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type IrpfgSignatures = keyof IrpfgTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type IrpfgNonVoidMethodSignatures = keyof IrpfgTypes['methods'] extends infer T ? T extends keyof IrpfgTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the Irpfg smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends IrpfgSignatures> = IrpfgTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Irpfg smart contract to the method's return type
 */
export type MethodReturn<TSignature extends IrpfgSignatures> = IrpfgTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = IrpfgTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = IrpfgTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type IrpfgCreateCallParams =
  | Expand<CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & {method: 'createApplication'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & {method: 'createApplication(address)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported delete method params for this smart contract
 */
export type IrpfgDeleteCallParams =
  | Expand<CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> & {method: 'deleteApplication'}>
  | Expand<CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> & {method: 'deleteApplication()void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type IrpfgDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: IrpfgCreateCallParams
  /**
   * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  deleteParams?: IrpfgDeleteCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Irpfg smart contract
 */
export abstract class IrpfgParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends IrpfgCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'createApplication':
          case 'createApplication(address)void':
            return IrpfgParamsFactory.create.createApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the irpfg smart contract using the createApplication(address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      createApplication(params: CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'createApplication(address)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.adminAddress],
        }
      },
    }
  }

  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod<TParams extends IrpfgDeleteCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'deleteApplication':
          case 'deleteApplication()void':
            return IrpfgParamsFactory.delete.deleteApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs delete ABI call params for the irpfg smart contract using the deleteApplication()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      deleteApplication(params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'deleteApplication()void' as const,
          args: Array.isArray(params.args) ? params.args : [],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the initApplication(uint64,uint64,pay,uint64,application)void ABI method
   *
  * Initializes the staking pool application with the specified staked asset and reward asset.
  
  Sets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset
  and reward asset if necesary.
  Only the admin address can call this function.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initApplication(params: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'initApplication(uint64,uint64,pay,uint64,application)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.stakedAssetId, params.args.rewardAssetId, params.args.initialBalanceTxn, params.args.fluxTierRequired, params.args.fluxOracleApp],
    }
  }
  /**
   * Constructs a no op call for the updateAdminAddress(account)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAdminAddress(params: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAdminAddress(account)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.adminAddress],
    }
  }
  /**
   * Constructs a no op call for the injectRewards(axfer,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static injectRewards(params: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'injectRewards(axfer,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardTxn, params.args.quantity, params.args.rewardAssetId],
    }
  }
  /**
   * Constructs a no op call for the stake(axfer,uint64,pay)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stake(params: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stake(axfer,uint64,pay)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.stakeTxn, params.args.quantity, params.args.mbrTxn],
    }
  }
  /**
   * Constructs a no op call for the claimRewards()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimRewards(params: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'claimRewards()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the unstake(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unstake(params: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'unstake(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.quantity],
    }
  }
  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gas(params: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'gas()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the irpfg smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class IrpfgFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `IrpfgFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new IrpfgClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new IrpfgClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the irpfg smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: IrpfgDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? IrpfgParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (IrpfgCreateCallParams & { args: Uint8Array[] }) : undefined,
      deleteParams: params.deleteParams?.method ? IrpfgParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams as (IrpfgDeleteCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new IrpfgClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the irpfg smart contract using the createApplication(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      createApplication: (params: CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(IrpfgParamsFactory.create.createApplication(params))
      },
    },

    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the irpfg smart contract using the deleteApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      deleteApplication: (params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> = {args: []}) => {
        return this.appFactory.params.deployDelete(IrpfgParamsFactory.delete.deleteApplication(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the irpfg smart contract using the createApplication(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      createApplication: (params: CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(IrpfgParamsFactory.create.createApplication(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the irpfg smart contract using an ABI method call using the createApplication(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      createApplication: async (params: CallParams<IrpfgArgs['obj']['createApplication(address)void'] | IrpfgArgs['tuple']['createApplication(address)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(IrpfgParamsFactory.create.createApplication(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | IrpfgReturns['createApplication(address)void']) }, appClient: new IrpfgClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the irpfg smart contract
 */
export class IrpfgClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `IrpfgClient`
   *
   * @param appClient An `AppClient` instance which has been created with the Irpfg app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `IrpfgClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends IrpfgNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `IrpfgClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<IrpfgClient> {
    return new IrpfgClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `IrpfgClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<IrpfgClient> {
    return new IrpfgClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the irpfg smart contract using the `deleteApplication()void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      deleteApplication: (params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> = {args: []}) => {
        return this.appClient.params.delete(IrpfgParamsFactory.delete.deleteApplication(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the irpfg smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the irpfg smart contract using the `initApplication(uint64,uint64,pay,uint64,application)void` ABI method.
     *
    * Initializes the staking pool application with the specified staked asset and reward asset.
    
    Sets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset
    and reward asset if necesary.
    Only the admin address can call this function.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initApplication: (params: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(IrpfgParamsFactory.initApplication(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `updateAdminAddress(account)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAdminAddress: (params: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(IrpfgParamsFactory.updateAdminAddress(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `injectRewards(axfer,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    injectRewards: (params: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(IrpfgParamsFactory.injectRewards(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `stake(axfer,uint64,pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stake: (params: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(IrpfgParamsFactory.stake(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `claimRewards()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimRewards: (params: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(IrpfgParamsFactory.claimRewards(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `unstake(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unstake: (params: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(IrpfgParamsFactory.unstake(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gas: (params: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(IrpfgParamsFactory.gas(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the irpfg smart contract using the `deleteApplication()void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      deleteApplication: (params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> = {args: []}) => {
        return this.appClient.createTransaction.delete(IrpfgParamsFactory.delete.deleteApplication(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the irpfg smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the irpfg smart contract using the `initApplication(uint64,uint64,pay,uint64,application)void` ABI method.
     *
    * Initializes the staking pool application with the specified staked asset and reward asset.
    
    Sets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset
    and reward asset if necesary.
    Only the admin address can call this function.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initApplication: (params: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.initApplication(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `updateAdminAddress(account)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAdminAddress: (params: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.updateAdminAddress(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `injectRewards(axfer,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    injectRewards: (params: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.injectRewards(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `stake(axfer,uint64,pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stake: (params: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.stake(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `claimRewards()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimRewards: (params: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.claimRewards(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `unstake(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unstake: (params: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.unstake(params))
    },

    /**
     * Makes a call to the irpfg smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gas: (params: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(IrpfgParamsFactory.gas(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the irpfg smart contract using the `deleteApplication()void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      deleteApplication: async (params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']> & SendParams = {args: []}) => {
        const result = await this.appClient.send.delete(IrpfgParamsFactory.delete.deleteApplication(params))
        return {...result, return: result.return as unknown as (undefined | IrpfgReturns['deleteApplication()void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the irpfg smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the irpfg smart contract using the `initApplication(uint64,uint64,pay,uint64,application)void` ABI method.
     *
    * Initializes the staking pool application with the specified staked asset and reward asset.
    
    Sets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset
    and reward asset if necesary.
    Only the admin address can call this function.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initApplication: async (params: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.initApplication(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['initApplication(uint64,uint64,pay,uint64,application)void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `updateAdminAddress(account)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAdminAddress: async (params: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.updateAdminAddress(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['updateAdminAddress(account)void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `injectRewards(axfer,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    injectRewards: async (params: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.injectRewards(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['injectRewards(axfer,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `stake(axfer,uint64,pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stake: async (params: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.stake(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['stake(axfer,uint64,pay)void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `claimRewards()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimRewards: async (params: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.claimRewards(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['claimRewards()void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `unstake(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unstake: async (params: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.unstake(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['unstake(uint64)void'])}
    },

    /**
     * Makes a call to the irpfg smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gas: async (params: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(IrpfgParamsFactory.gas(params))
      return {...result, return: result.return as unknown as (undefined | IrpfgReturns['gas()void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new IrpfgClient(this.appClient.clone(params))
  }

  /**
   * Methods to access state for the current irpfg app
   */
  state = {
    /**
     * Methods to access global state for the current irpfg app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          stakedAssetId: result.staked_asset_id,
          rewardAssetId: result.reward_asset_id,
          totalStaked: result.total_staked,
          currentAsaRewardIndex: result.current_asa_reward_index,
          lastRewardInjectionTime: result.last_reward_injection_time,
          adminAddress: result.admin_address,
          numStakers: result.num_stakers,
          contractVersion: result.contract_version,
          fluxTierRequired: result.flux_tier_required,
          fluxOracleApp: result.flux_oracle_app,
        }
      },
      /**
       * Get the current value of the staked_asset_id key in global state
       */
      stakedAssetId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("staked_asset_id")) as bigint | undefined },
      /**
       * Get the current value of the reward_asset_id key in global state
       */
      rewardAssetId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("reward_asset_id")) as bigint | undefined },
      /**
       * Get the current value of the total_staked key in global state
       */
      totalStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("total_staked")) as bigint | undefined },
      /**
       * Get the current value of the current_asa_reward_index key in global state
       */
      currentAsaRewardIndex: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("current_asa_reward_index")) as bigint | undefined },
      /**
       * Get the current value of the last_reward_injection_time key in global state
       */
      lastRewardInjectionTime: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("last_reward_injection_time")) as bigint | undefined },
      /**
       * Get the current value of the admin_address key in global state
       */
      adminAddress: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("admin_address")) as string | undefined },
      /**
       * Get the current value of the num_stakers key in global state
       */
      numStakers: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("num_stakers")) as bigint | undefined },
      /**
       * Get the current value of the contract_version key in global state
       */
      contractVersion: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("contract_version")) as bigint | undefined },
      /**
       * Get the current value of the flux_tier_required key in global state
       */
      fluxTierRequired: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("flux_tier_required")) as number | undefined },
      /**
       * Get the current value of the flux_oracle_app key in global state
       */
      fluxOracleApp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("flux_oracle_app")) as bigint | undefined },
    },
    /**
     * Methods to access box state for the current irpfg app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the stakers map in box state
       */
      stakers: {
        /**
         * Get all current values of the stakers map in box state
         */
        getMap: async (): Promise<Map<string, StakeInfoRecord>> => { return (await this.appClient.state.box.getMap("stakers")) as Map<string, StakeInfoRecord> },
        /**
         * Get a current value of the stakers map by key from box state
         */
        value: async (key: string): Promise<StakeInfoRecord | undefined> => { return await this.appClient.state.box.getMapValue("stakers", key) as StakeInfoRecord | undefined },
      },
    },
  }

  public newGroup(): IrpfgComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a initApplication(uint64,uint64,pay,uint64,application)void method call against the irpfg contract
       */
      initApplication(params: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initApplication(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAdminAddress(account)void method call against the irpfg contract
       */
      updateAdminAddress(params: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAdminAddress(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a injectRewards(axfer,uint64,uint64)void method call against the irpfg contract
       */
      injectRewards(params: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.injectRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a stake(axfer,uint64,pay)void method call against the irpfg contract
       */
      stake(params: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stake(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a claimRewards()void method call against the irpfg contract
       */
      claimRewards(params: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a unstake(uint64)void method call against the irpfg contract
       */
      unstake(params: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unstake(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a gas()void method call against the irpfg contract
       */
      gas(params: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gas(params)))
        resultMappers.push(undefined)
        return this
      },
      get delete() {
        return {
          deleteApplication: (params: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.deleteApplication(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the irpfg contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as IrpfgComposer
  }
}
export type IrpfgComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initApplication(uint64,uint64,pay,uint64,application)void ABI method.
   *
  * Initializes the staking pool application with the specified staked asset and reward asset.
  
  Sets up global state variables, verifies the initial funding payment, and opts the contract into the staked asset
  and reward asset if necesary.
  Only the admin address can call this function.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initApplication(params?: CallParams<IrpfgArgs['obj']['initApplication(uint64,uint64,pay,uint64,application)void'] | IrpfgArgs['tuple']['initApplication(uint64,uint64,pay,uint64,application)void']>): IrpfgComposer<[...TReturns, IrpfgReturns['initApplication(uint64,uint64,pay,uint64,application)void'] | undefined]>

  /**
   * Calls the updateAdminAddress(account)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAdminAddress(params?: CallParams<IrpfgArgs['obj']['updateAdminAddress(account)void'] | IrpfgArgs['tuple']['updateAdminAddress(account)void']>): IrpfgComposer<[...TReturns, IrpfgReturns['updateAdminAddress(account)void'] | undefined]>

  /**
   * Calls the injectRewards(axfer,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  injectRewards(params?: CallParams<IrpfgArgs['obj']['injectRewards(axfer,uint64,uint64)void'] | IrpfgArgs['tuple']['injectRewards(axfer,uint64,uint64)void']>): IrpfgComposer<[...TReturns, IrpfgReturns['injectRewards(axfer,uint64,uint64)void'] | undefined]>

  /**
   * Calls the stake(axfer,uint64,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stake(params?: CallParams<IrpfgArgs['obj']['stake(axfer,uint64,pay)void'] | IrpfgArgs['tuple']['stake(axfer,uint64,pay)void']>): IrpfgComposer<[...TReturns, IrpfgReturns['stake(axfer,uint64,pay)void'] | undefined]>

  /**
   * Calls the claimRewards()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  claimRewards(params?: CallParams<IrpfgArgs['obj']['claimRewards()void'] | IrpfgArgs['tuple']['claimRewards()void']>): IrpfgComposer<[...TReturns, IrpfgReturns['claimRewards()void'] | undefined]>

  /**
   * Calls the unstake(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unstake(params?: CallParams<IrpfgArgs['obj']['unstake(uint64)void'] | IrpfgArgs['tuple']['unstake(uint64)void']>): IrpfgComposer<[...TReturns, IrpfgReturns['unstake(uint64)void'] | undefined]>

  /**
   * Calls the gas()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(params?: CallParams<IrpfgArgs['obj']['gas()void'] | IrpfgArgs['tuple']['gas()void']>): IrpfgComposer<[...TReturns, IrpfgReturns['gas()void'] | undefined]>

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the irpfg smart contract using the deleteApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteApplication(params?: CallParams<IrpfgArgs['obj']['deleteApplication()void'] | IrpfgArgs['tuple']['deleteApplication()void']>): IrpfgComposer<[...TReturns, IrpfgReturns['deleteApplication()void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the irpfg smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): IrpfgComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): IrpfgComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<IrpfgComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<IrpfgComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<IrpfgComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<IrpfgComposerResults<TReturns>>
}
export type IrpfgComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

