#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 1000 1000000000000000
    bytecblock "st" "reward_asset_id" "total_staked" "reward_per_token" "admin_address" "staked_asset_id" "num_stakers" 0x0000000000000000 "last_reward_injection_time" "flux_tier_required" "flux_oracle_app"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn NumAppArgs
    bz main_after_if_else@15
    pushbytess 0xd324bea4 0x94202064 0x32db7a6d 0x347007eb 0x2487c32c 0x7a9ee189 0xa5ae6bd1 0x813ce89a 0x3172ca9d // method "createApplication(address)void", method "initApplication(uint64,uint64,pay,uint64,application)void", method "updateAdminAddress(account)void", method "injectRewards(axfer,uint64,uint64)void", method "deleteApplication()void", method "stake(axfer,uint64,pay)void", method "claimRewards()void", method "unstake(uint64)void", method "gas()void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_initApplication_route@4 main_updateAdminAddress_route@5 main_injectRewards_route@6 main_deleteApplication_route@7 main_stake_route@8 main_claimRewards_route@9 main_unstake_route@10 main_gas_route@11

main_after_if_else@15:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    intc_0 // 0
    return

main_gas_route@11:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:331
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_unstake_route@10:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272
    // @abimethod({ allowActions: "NoOp" })
    callsub unstake
    intc_1 // 1
    return

main_claimRewards_route@9:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:240
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_stake_route@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:165
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:165
    // @abimethod({ allowActions: "NoOp" })
    callsub stake
    intc_1 // 1
    return

main_deleteApplication_route@7:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:136
    // @abimethod({ allowActions: "DeleteApplication" })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_1 // 1
    return

main_injectRewards_route@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117
    // @abimethod({ allowActions: "NoOp" })
    callsub injectRewards
    intc_1 // 1
    return

main_updateAdminAddress_route@5:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108
    // @abimethod({ allowActions: "NoOp" })
    callsub updateAdminAddress
    intc_1 // 1
    return

main_initApplication_route@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txnas Applications
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    callsub initApplication
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.createApplication(adminAddress: bytes) -> void:
createApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48-49
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // createApplication(adminAddress: Address): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:50
    // this.admin_address.value = adminAddress.native;
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // contract_version = GlobalState<UintN64>();
    pushbytess "contract_version" 0x0000000000000fa0 // "contract_version", 0x0000000000000fa0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:51
    // this.contract_version.value = new UintN64(VERSION);
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.initApplication(stakedAssetId: uint64, rewardAssetId: uint64, initialBalanceTxn: uint64, fluxTierRequired: uint64, fluxOracleApp: uint64) -> void:
initApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64-71
    // @abimethod({ allowActions: "NoOp" })
    // initApplication(
    //   stakedAssetId: uint64,
    //   rewardAssetId: uint64,
    //   initialBalanceTxn: gtxn.PaymentTxn,
    //   fluxTierRequired: uint64,
    //   fluxOracleApp: Application
    // ): void {
    proto 5 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:72
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:72
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    ==
    assert // Only admin can init application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:74
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    frame_dig -5
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    bytec 5 // "staked_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:74
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:75
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    frame_dig -4
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    bytec_1 // "reward_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:75
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:76
    // this.total_staked.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:36
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 8 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:77
    // this.last_reward_injection_time.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    bytec_3 // "reward_per_token"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:78
    // this.reward_per_token.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:79
    // this.num_stakers.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    frame_dig -2
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // flux_tier_required = GlobalState<UintN8>();
    bytec 9 // "flux_tier_required"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // flux_oracle_app = GlobalState<Application>();
    bytec 10 // "flux_oracle_app"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:81
    // this.flux_oracle_app.value = fluxOracleApp;
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    frame_dig -3
    gtxns Receiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:84
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    frame_dig -3
    gtxns Amount
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:15
    // export const INITIAL_PAY_AMOUNT: uint64 = 400_000;
    pushint 400000 // 400000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    intc_1 // 1

initApplication_bool_merge@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-95
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:91
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:92
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -5
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-94
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-95
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:96
    // if (rewardAssetId !== stakedAssetId) {
    frame_dig -4
    frame_dig -5
    !=
    bz initApplication_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-104
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:100
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:101
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-103
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-104
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

initApplication_after_if_else@8:
    retsub

initApplication_bool_false@3:
    intc_0 // 0
    b initApplication_bool_merge@4


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.updateAdminAddress(adminAddress: bytes) -> void:
updateAdminAddress:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108-109
    // @abimethod({ allowActions: "NoOp" })
    // updateAdminAddress(adminAddress: Account): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:110
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:110
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    ==
    assert // Only admin can update admin address
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:111
    // this.admin_address.value = adminAddress;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.injectRewards(rewardTxn: uint64, quantity: uint64, rewardAssetId: uint64) -> void:
injectRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117-118
    // @abimethod({ allowActions: "NoOp" })
    // injectRewards(rewardTxn: gtxn.AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void {
    proto 3 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:119
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:119
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    ==
    assert // Only admin can inject rewards
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:120
    // assert(quantity > 0, "Invalid reward quantity");
    frame_dig -2
    assert // Invalid reward quantity
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:121
    // assert(rewardAssetId === this.reward_asset_id.value.native, "Wrong reward asset");
    btoi
    frame_dig -1
    ==
    assert // Wrong reward asset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123-128
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    frame_dig -3
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123-128
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:125
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123-128
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:126
    // xferAsset: Asset(this.reward_asset_id.value.native),
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123-128
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetAmount
    frame_dig -2
    ==
    bz injectRewards_bool_false@5
    intc_1 // 1

injectRewards_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123-128
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:129
    // assert(this.total_staked.value.native > 0, "No stakers");
    btoi
    assert // No stakers
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:131
    // const deltaRPT = mulDivW(quantity, PRECISION, this.total_staked.value.native);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // assert(c > 0, "mulDivW: division by zero");
    dup
    assert // mulDivW: division by zero
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    frame_dig -2
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    uncover 2
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:132
    // this.reward_per_token.value = new UintN64(this.reward_per_token.value.native + deltaRPT);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    bytec_3 // "reward_per_token"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:132
    // this.reward_per_token.value = new UintN64(this.reward_per_token.value.native + deltaRPT);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:133
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    global LatestTimestamp
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:36
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 8 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:133
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    swap
    app_global_put
    retsub

injectRewards_bool_false@5:
    intc_0 // 0
    b injectRewards_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:138
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:138
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    ==
    assert // Only admin can delete application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:139
    // assert(this.total_staked.value.native === 0, "Staked assets still exist");
    btoi
    !
    assert // Staked assets still exist
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:142-150
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:144
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:145
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:147
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:146
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:142-149
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:142-150
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:152
    // if (this.staked_asset_id.value !== this.reward_asset_id.value) {
    !=
    bz deleteApplication_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:153-161
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:155
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:156
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:158
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:157
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:153-160
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:153-161
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

deleteApplication_after_if_else@4:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.stake(stakeTxn: uint64, quantity: uint64, mbrTxn: uint64) -> void:
stake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:165-166
    // @abimethod({ allowActions: "NoOp" })
    // stake(stakeTxn: gtxn.AssetTransferTxn, quantity: uint64, mbrTxn: gtxn.PaymentTxn): void {
    proto 3 0
    pushbytes ""
    dupn 5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:167
    // assert(quantity > 0, "Invalid quantity");
    frame_dig -2
    assert // Invalid quantity
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:169-174
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    frame_dig -3
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:170
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:169-174
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:169-174
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:172
    // xferAsset: Asset(this.staked_asset_id.value.native),
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:169-174
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns AssetAmount
    frame_dig -2
    ==
    bz stake_bool_false@5
    intc_1 // 1

stake_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:169-174
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // flux_oracle_app = GlobalState<Application>();
    intc_0 // 0
    bytec 10 // "flux_oracle_app"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177-184
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: oracle.id,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:180
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:183
    // accounts: [op.Txn.sender],
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:179
    // args: [new arc4.Address(op.Txn.sender)],
    dup
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177-184
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: oracle.id,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    pushbytes 0xd4d7aa5c // method "getUserTier(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field Accounts
    dig 1
    itxn_field Applications
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177-184
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: oracle.id,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    pushbytes 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:185
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // flux_tier_required = GlobalState<UintN8>();
    intc_0 // 0
    bytec 9 // "flux_tier_required"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:185
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    >=
    assert // Insufficient flux tier
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:187
    // const exists = this.stakers(op.Txn.sender).exists;
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:187
    // const exists = this.stakers(op.Txn.sender).exists;
    box_len
    dup
    cover 2
    frame_bury 1
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:188
    // if (!exists) {
    bnz stake_after_if_else@14
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:189-193
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    frame_dig -1
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:190
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:189-193
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@12
    frame_dig -1
    gtxns Receiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:191
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:189-193
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@12
    frame_dig -1
    gtxns Amount
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const BOX_FEE: uint64 = 22_500;
    pushint 22500 // 22500
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:189-193
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@12
    intc_1 // 1

stake_bool_merge@13:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:189-193
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    assert // assert target is match for conditions

stake_after_if_else@14:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.native : 0;
    frame_dig 1
    bz stake_ternary_false@16
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.native : 0;
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.native : 0;
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 5

stake_ternary_merge@17:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:197
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.native : 0;
    frame_dig 1
    bz stake_ternary_false@19
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:197
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.native : 0;
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:197
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.native : 0;
    box_get
    assert // Box must have value
    pushint 8 // 8
    extract_uint64
    frame_bury 4

stake_ternary_merge@20:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:201
    // const accrued = mulDivW(prevStake, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    frame_dig 5
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:202
    // const pending: uint64 = accrued > prevDebt ? accrued - prevDebt : 0;
    frame_dig 4
    >
    bz stake_ternary_false@22
    frame_dig 0
    frame_dig 4
    -
    frame_bury 3

stake_ternary_merge@23:
    frame_dig 5
    frame_bury 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:206
    // if (pending > 0) {
    frame_dig 3
    bz stake_after_if_else@29
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:207
    // if (this.staked_asset_id.value.native === this.reward_asset_id.value.native) {
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:207
    // if (this.staked_asset_id.value.native === this.reward_asset_id.value.native) {
    btoi
    ==
    bz stake_else_body@26
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:209
    // newStake = newStake + pending;
    frame_dig 5
    frame_dig 3
    dup
    cover 2
    +
    frame_bury 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210
    // this.total_staked.value = new UintN64(this.total_staked.value.native + pending);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210
    // this.total_staked.value = new UintN64(this.total_staked.value.native + pending);
    swap
    app_global_put

stake_after_if_else@29:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:225
    // newStake = newStake + quantity;
    frame_dig 2
    frame_dig -2
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:226
    // this.total_staked.value = new UintN64(this.total_staked.value.native + quantity);
    btoi
    frame_dig -2
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:226
    // this.total_staked.value = new UintN64(this.total_staked.value.native + quantity);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:229
    // const newDebt = mulDivW(newStake, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 1
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:231
    // stake: new UintN64(newStake),
    swap
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:232
    // rewardDebt: new UintN64(newDebt),
    swap
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:230-233
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(newStake),
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:230
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:230-233
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(newStake),
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:235
    // if (!exists) {
    frame_dig 1
    bnz stake_after_if_else@31
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:236
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    btoi
    intc_1 // 1
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:236
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    swap
    app_global_put

stake_after_if_else@31:
    retsub

stake_else_body@26:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:212-220
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:214
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:215
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:216
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 3
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:212-219
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:212-220
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    frame_dig 5
    frame_bury 2
    b stake_after_if_else@29

stake_ternary_false@22:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:202
    // const pending: uint64 = accrued > prevDebt ? accrued - prevDebt : 0;
    intc_0 // 0
    frame_bury 3
    b stake_ternary_merge@23

stake_ternary_false@19:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:197
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.native : 0;
    intc_0 // 0
    frame_bury 4
    b stake_ternary_merge@20

stake_ternary_false@16:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.native : 0;
    intc_0 // 0
    frame_bury 5
    b stake_ternary_merge@17

stake_bool_false@12:
    intc_0 // 0
    b stake_bool_merge@13

stake_bool_false@5:
    intc_0 // 0
    b stake_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.claimRewards() -> void:
claimRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:240-241
    // @abimethod({ allowActions: "NoOp" })
    // claimRewards(): void {
    proto 0 0
    pushbytes ""
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:243
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:243
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:244
    // assert(this.staked_asset_id.value.native !== this.reward_asset_id.value.native, "Cannot claim rewards that compound");
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:244
    // assert(this.staked_asset_id.value.native !== this.reward_asset_id.value.native, "Cannot claim rewards that compound");
    btoi
    !=
    assert // Cannot claim rewards that compound
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:246
    // const staker = this.stakers(op.Txn.sender).value.copy();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:246
    // const staker = this.stakers(op.Txn.sender).value.copy();
    box_get
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:247
    // assert(staker.stake.native > 0, "No stake");
    dup
    extract 0 8 // on error: Index access is out of bounds
    swap
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    dup
    assert // No stake
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:250
    // const accrued = mulDivW(staker.stake.native, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    uncover 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:251
    // const pending: uint64 = accrued > staker.rewardDebt.native ? accrued - staker.rewardDebt.native : 0;
    pushint 8 // 8
    extract_uint64
    dup
    cover 2
    >
    bz claimRewards_ternary_false@2
    frame_dig 3
    frame_dig 4
    -
    frame_bury 0

claimRewards_ternary_merge@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:253
    // if (pending > 0) {
    frame_dig 0
    bz claimRewards_after_if_else@6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:254-262
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:256
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:257
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:258
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 0
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:254-261
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:254-262
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

claimRewards_after_if_else@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:265
    // const newDebt = mulDivW(staker.stake.native, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    frame_dig 2
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:268
    // rewardDebt: new UintN64(newDebt),
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:266-269
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    frame_dig 1
    swap
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:266
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:266-269
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    swap
    box_put
    retsub

claimRewards_ternary_false@2:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:251
    // const pending: uint64 = accrued > staker.rewardDebt.native ? accrued - staker.rewardDebt.native : 0;
    intc_0 // 0
    frame_bury 0
    b claimRewards_ternary_merge@3


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.unstake(quantity: uint64) -> void:
unstake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272-273
    // @abimethod({ allowActions: "NoOp" })
    // unstake(quantity: uint64): void {
    proto 1 0
    pushbytes ""
    dup
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:275
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:275
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:276
    // const rec = this.stakers(op.Txn.sender).value.copy();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:276
    // const rec = this.stakers(op.Txn.sender).value.copy();
    box_get
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:277
    // const stakeNow: uint64 = rec.stake.native;
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:278
    // assert(stakeNow > 0, "No stake");
    dup
    assert // No stake
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:280
    // const amountToWithdraw: uint64 = quantity === 0 ? stakeNow : quantity;
    frame_dig -1
    !
    frame_dig -1
    dig 2
    uncover 2
    select
    dup
    cover 3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:281
    // assert(stakeNow >= amountToWithdraw, "Unstake amount exceeds balance");
    dig 1
    <=
    assert // Unstake amount exceeds balance
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:285
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    uncover 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:286
    // const pending: uint64 = accrued > rec.rewardDebt.native ? accrued - rec.rewardDebt.native : 0;
    pushint 8 // 8
    extract_uint64
    dup
    cover 2
    >
    bz unstake_ternary_false@2
    frame_dig 4
    frame_dig 5
    -
    frame_bury 0

unstake_ternary_merge@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:288
    // if (pending > 0) {
    frame_dig 0
    bz unstake_after_if_else@6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:290-298
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:292
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:293
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:294
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 0
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:290-297
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:290-298
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: pending,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

unstake_after_if_else@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:302-310
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:304
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:305
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:306
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 3
    dup
    cover 4
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:302-309
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:302-310
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:313
    // this.total_staked.value = new UintN64(this.total_staked.value.native - amountToWithdraw);
    btoi
    dig 1
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:313
    // this.total_staked.value = new UintN64(this.total_staked.value.native - amountToWithdraw);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:316
    // const remaining: uint64 = stakeNow - amountToWithdraw;
    frame_dig 2
    swap
    -
    dup
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:317
    // if (remaining === 0) {
    bnz unstake_else_body@9
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:319
    // this.stakers(op.Txn.sender).delete();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:319
    // this.stakers(op.Txn.sender).delete();
    box_del
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:320
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    btoi
    intc_1 // 1
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:320
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    swap
    app_global_put
    retsub

unstake_else_body@9:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // reward_per_token = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "reward_per_token"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:323
    // const newDebt = mulDivW(remaining, this.reward_per_token.value.native, PRECISION);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    frame_dig 1
    dup
    uncover 2
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:325
    // stake: new UintN64(remaining),
    swap
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:326
    // rewardDebt: new UintN64(newDebt),
    swap
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:324-327
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(remaining),
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:324
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:324-327
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(remaining),
    //   rewardDebt: new UintN64(newDebt),
    // }).copy();
    swap
    box_put
    retsub

unstake_ternary_false@2:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:286
    // const pending: uint64 = accrued > rec.rewardDebt.native ? accrued - rec.rewardDebt.native : 0;
    intc_0 // 0
    frame_bury 0
    b unstake_ternary_merge@3
