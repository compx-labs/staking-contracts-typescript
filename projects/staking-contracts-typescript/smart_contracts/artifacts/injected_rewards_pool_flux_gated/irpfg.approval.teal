#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 48 300 700 1000 650 100000 9605300 53300 1000000000000000
    bytecblock "stakers" "num_stakers" "total_staked" "injected_asa_rewards" "reward_asset_id" 0x0000000000000000 "admin_address" "staked_asset_id" 0x151f7c75 0x068101 "last_reward_injection_time" "flux_tier_required" "flux_oracle_app" base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn NumAppArgs
    bz main_after_if_else@18
    pushbytess 0xd324bea4 0x94202064 0x32db7a6d 0x4c436726 0x47cfcc04 0x347007eb 0x2487c32c 0xf4eb4a03 0xea4bca57 0xa5ae6bd1 0x813ce89a 0x3172ca9d // method "createApplication(address)void", method "initApplication(uint64,uint64,pay,uint64,application)void", method "updateAdminAddress(account)void", method "getMBRForPoolCreation()(uint64)", method "initStorage(pay)void", method "injectRewards(axfer,uint64,uint64)void", method "deleteApplication()void", method "stake(axfer,uint64)void", method "accrueRewards()void", method "claimRewards()void", method "unstake(uint64)void", method "gas()void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_initApplication_route@4 main_updateAdminAddress_route@5 main_getMBRForPoolCreation_route@6 main_initStorage_route@7 main_injectRewards_route@8 main_deleteApplication_route@9 main_stake_route@10 main_accrueRewards_route@11 main_claimRewards_route@12 main_unstake_route@13 main_gas_route@14

main_after_if_else@18:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    intc_0 // 0
    return

main_gas_route@14:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:512
    // gas(): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_unstake_route@13:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:407
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:407
    // @abimethod({ allowActions: "NoOp" })
    callsub unstake
    intc_1 // 1
    return

main_claimRewards_route@12:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:386
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_accrueRewards_route@11:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:311
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub accrueRewards
    intc_1 // 1
    return

main_stake_route@10:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:228
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:228
    // @abimethod({ allowActions: "NoOp" })
    callsub stake
    intc_1 // 1
    return

main_deleteApplication_route@9:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:191
    // @abimethod({ allowActions: "DeleteApplication" })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_1 // 1
    return

main_injectRewards_route@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177
    // @abimethod({ allowActions: "NoOp" })
    callsub injectRewards
    intc_1 // 1
    return

main_initStorage_route@7:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:154
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:154
    // @abimethod({ allowActions: "NoOp" })
    callsub initStorage
    intc_1 // 1
    return

main_getMBRForPoolCreation_route@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:137
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getMBRForPoolCreation
    itob
    bytec 8 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdminAddress_route@5:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:124
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:124
    // @abimethod({ allowActions: "NoOp" })
    callsub updateAdminAddress
    intc_1 // 1
    return

main_initApplication_route@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txnas Applications
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // @abimethod({ allowActions: "NoOp" })
    callsub initApplication
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34-35
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_1 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 9 // 0x068101
    itxn_field ApprovalProgram
    bytec 9 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.createApplication(adminAddress: bytes) -> void:
createApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64-65
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // createApplication(adminAddress: Address): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    bytec 6 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:66
    // this.admin_address.value = adminAddress.native;
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:58
    // contract_version = GlobalState<UintN64>();
    pushbytess "contract_version" 0x0000000000000bc2 // "contract_version", 0x0000000000000bc2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:67
    // this.contract_version.value = new UintN64(VERSION);
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.initApplication(stakedAssetId: uint64, rewardAssetId: uint64, initialBalanceTxn: uint64, fluxTierRequired: uint64, fluxOracleApp: uint64) -> void:
initApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80-87
    // @abimethod({ allowActions: "NoOp" })
    // initApplication(
    //   stakedAssetId: uint64,
    //   rewardAssetId: uint64,
    //   initialBalanceTxn: gtxn.PaymentTxn,
    //   fluxTierRequired: uint64,
    //   fluxOracleApp: Application
    // ): void {
    proto 5 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    ==
    assert // Only admin can init application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:90
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    frame_dig -5
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    bytec 7 // "staked_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:90
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:91
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    frame_dig -4
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    bytec 4 // "reward_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:91
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:92
    // this.total_staked.value = new UintN64(0);
    bytec 5 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 10 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:93
    // this.last_reward_injection_time.value = new UintN64(0);
    bytec 5 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    bytec_3 // "injected_asa_rewards"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:94
    // this.injected_asa_rewards.value = new UintN64(0);
    bytec 5 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    bytec_1 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:95
    // this.num_stakers.value = new UintN64(0);
    bytec 5 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:96
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    frame_dig -2
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:60
    // flux_tier_required = GlobalState<UintN8>();
    bytec 11 // "flux_tier_required"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:96
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:62
    // flux_oracle_app = GlobalState<Application>();
    bytec 12 // "flux_oracle_app"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97
    // this.flux_oracle_app.value = fluxOracleApp
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:99-102
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    frame_dig -3
    gtxns Receiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:100
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:99-102
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    frame_dig -3
    gtxns Amount
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const INITIAL_PAY_AMOUNT: uint64 = 10_000_000;
    pushint 10000000 // 10000000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:99-102
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    intc_1 // 1

initApplication_bool_merge@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:99-102
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:104-111
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:107
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -5
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:104-110
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:104-111
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:112
    // if (rewardAssetId !== stakedAssetId) {
    frame_dig -4
    frame_dig -5
    !=
    bz initApplication_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:113-120
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:116
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:113-119
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:113-120
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

initApplication_after_if_else@8:
    retsub

initApplication_bool_false@3:
    intc_0 // 0
    b initApplication_bool_merge@4


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.updateAdminAddress(adminAddress: bytes) -> void:
updateAdminAddress:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:124-125
    // @abimethod({ allowActions: "NoOp" })
    // updateAdminAddress(adminAddress: Account): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:126
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:126
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    ==
    assert // Only admin can update admin address
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    bytec 6 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:127
    // this.admin_address.value = adminAddress;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.getMBRForPoolCreation() -> uint64:
getMBRForPoolCreation:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:137-138
    // @abimethod({ allowActions: "NoOp" })
    // getMBRForPoolCreation(): mbrReturn {
    proto 0 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:139
    // let nonAlgoRewardMBR: uint64 = 0;
    intc_0 // 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    dup
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:140
    // if (this.reward_asset_id.value.native !== 0) {
    btoi
    bz getMBRForPoolCreation_after_if_else@2
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:13
    // export const ASSET_HOLDING_FEE: uint64 = 100000; // creation/holding fee for asset
    intc 7 // 100000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:141
    // nonAlgoRewardMBR += ASSET_HOLDING_FEE;
    frame_bury 0

getMBRForPoolCreation_after_if_else@2:
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:14
    // export const ALGORAND_ACCOUNT_MIN_BALANCE: uint64 = 100000;
    intc 7 // 100000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:144-145
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    frame_dig 0
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:134
    // return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
    intc 8 // 9605300
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:144-146
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    // this.costForBoxStorage(7 + 48 * MAX_STAKERS_PER_POOL) +
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:134
    // return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
    intc 9 // 53300
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:144-147
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    // this.costForBoxStorage(7 + 48 * MAX_STAKERS_PER_POOL) +
    // this.costForBoxStorage(7 + 8 * 15);
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:149-151
    // return {
    //   mbrPayment: mbr,
    // };
    swap
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.initStorage(mbrPayment: uint64) -> void:
initStorage:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:154-155
    // @abimethod({ allowActions: "NoOp" })
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    proto 1 0
    pushbytes ""
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:156
    // assert(!this.stakers.exists, "staking pool already initialized");
    box_len
    bury 1
    !
    assert // staking pool already initialized
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:157
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init storage");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:157
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init storage");
    ==
    assert // Only admin can init storage
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:159
    // let nonAlgoRewardMBR: uint64 = 0;
    intc_0 // 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    dup
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:160
    // if (this.reward_asset_id.value.native !== 0) {
    btoi
    bz initStorage_after_if_else@2
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:13
    // export const ASSET_HOLDING_FEE: uint64 = 100000; // creation/holding fee for asset
    intc 7 // 100000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:161
    // nonAlgoRewardMBR += ASSET_HOLDING_FEE;
    frame_bury 1

initStorage_after_if_else@2:
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:14
    // export const ALGORAND_ACCOUNT_MIN_BALANCE: uint64 = 100000;
    intc 7 // 100000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-165
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    frame_dig 1
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:134
    // return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
    intc 8 // 9605300
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-166
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    // this.costForBoxStorage(7 + 48 * MAX_STAKERS_PER_POOL) +
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:134
    // return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
    intc 9 // 53300
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-167
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // nonAlgoRewardMBR +
    // this.costForBoxStorage(7 + 48 * MAX_STAKERS_PER_POOL) +
    // this.costForBoxStorage(7 + 8 * 15);
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:163-167
    // const poolMBR: uint64 =
    //   ALGORAND_ACCOUNT_MIN_BALANCE +
    //   nonAlgoRewardMBR +
    //   this.costForBoxStorage(7 + 48 * MAX_STAKERS_PER_POOL) +
    //   this.costForBoxStorage(7 + 8 * 15);
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:170
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: poolMBR });
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    bz initStorage_bool_false@5
    frame_dig -1
    gtxns Amount
    frame_dig 0
    ==
    bz initStorage_bool_false@5
    intc_1 // 1

initStorage_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:170
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: poolMBR });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171
    // this.stakers.create();
    pushint 31200 // 31200
    box_create
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:172
    // this.minimum_balance.value = new UintN64(poolMBR);
    frame_dig 0
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:54
    // minimum_balance = GlobalState<UintN64>();
    pushbytes "minimum_balance"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:172
    // this.minimum_balance.value = new UintN64(poolMBR);
    swap
    app_global_put
    retsub

initStorage_bool_false@5:
    intc_0 // 0
    b initStorage_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.injectRewards(rewardTxn: uint64, quantity: uint64, rewardAssetId: uint64) -> void:
injectRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:177-178
    // @abimethod({ allowActions: "NoOp" })
    // injectRewards(rewardTxn: gtxn.AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void {
    proto 3 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:179
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:179
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    ==
    assert // Only admin can inject rewards
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:181-186
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    frame_dig -3
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:181-186
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:183
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:181-186
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns XferAsset
    frame_dig -1
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetAmount
    frame_dig -2
    ==
    bz injectRewards_bool_false@5
    intc_1 // 1

injectRewards_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:181-186
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:187
    // this.injected_asa_rewards.value = new UintN64(this.injected_asa_rewards.value.native + quantity);
    btoi
    frame_dig -2
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    bytec_3 // "injected_asa_rewards"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:187
    // this.injected_asa_rewards.value = new UintN64(this.injected_asa_rewards.value.native + quantity);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:188
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    global LatestTimestamp
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 10 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:188
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    swap
    app_global_put
    retsub

injectRewards_bool_false@5:
    intc_0 // 0
    b injectRewards_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:193
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:52
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec 6 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:193
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    ==
    assert // Only admin can delete application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:194
    // assert(this.total_staked.value.native === 0, "Staked assets still exist");
    btoi
    !
    assert // Staked assets still exist
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // this.stakers.delete();
    box_del
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199-207
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:201
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:202
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:204
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:203
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199-206
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199-207
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:209
    // if (this.staked_asset_id.value !== this.reward_asset_id.value) {
    !=
    bz deleteApplication_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210-218
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:212
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:213
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:215
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:214
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210-217
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210-218
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

deleteApplication_after_if_else@4:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.stake(stakeTxn: uint64, quantity: uint64) -> void:
stake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:228-229
    // @abimethod({ allowActions: "NoOp" })
    // stake(stakeTxn: gtxn.AssetTransferTxn, quantity: uint64): void {
    proto 2 0
    intc_0 // 0
    pushbytes ""
    dupn 5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:231
    // assert(quantity > 0, "Invalid quantity");
    frame_dig -1
    assert // Invalid quantity
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:62
    // flux_oracle_app = GlobalState<Application>();
    intc_0 // 0
    bytec 12 // "flux_oracle_app"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:234
    // const address = oracle.address
    dup
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:238-245
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:241
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:244
    // accounts: [op.Txn.sender],
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:240
    // args: [new arc4.Address(op.Txn.sender)],
    dup
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:238-245
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    pushbytes 0xd4d7aa5c // method "getUserTier(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field Accounts
    dig 1
    itxn_field Applications
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:238-245
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 8 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:247
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:60
    // flux_tier_required = GlobalState<UintN8>();
    intc_0 // 0
    bytec 11 // "flux_tier_required"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:247
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    >=
    assert // Insufficient flux tier
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:249
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:250
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:252-257
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    frame_dig -2
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:253
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:252-257
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@8
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:254
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:252-257
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@8
    frame_dig -2
    gtxns XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:255
    // xferAsset: Asset(this.staked_asset_id.value.native),
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:252-257
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@8
    frame_dig -2
    gtxns AssetAmount
    frame_dig -1
    ==
    bz stake_bool_false@8
    intc_1 // 1

stake_bool_merge@9:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:252-257
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:258
    // let actionComplete: boolean = false;
    intc_0 // 0
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:259
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@11
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:260
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@11:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:262
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 2

stake_while_top@12:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:262
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_get
    bury 1
    assert // Box must have value
    frame_dig 2
    intc 6 // 650
    <
    dup
    frame_bury 4
    bz stake_block@35
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:263
    // if (actionComplete) break;
    frame_dig 1
    bnz stake_block@35
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:265
    // if (this.stakers.value[i].account === new arc4.Address(op.Txn.sender)) {
    box_get
    assert // Box must have value
    frame_dig 2
    intc_2 // 48
    *
    dup
    frame_bury 3
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    txn Sender
    ==
    bz stake_else_body@21
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:267
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@18
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:268
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@18:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:271
    // const staker = this.stakers.value[i].copy();
    box_get
    assert // Box must have value
    frame_dig 3
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272
    // staker.stake = new UintN64(staker.stake.native + stakeTxn.assetAmount);
    dup
    pushint 32 // 32
    extract_uint64
    frame_dig -2
    gtxns AssetAmount
    dup
    frame_bury 5
    +
    itob
    replace2 32
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:274
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@20
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:275
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@20:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:277
    // this.stakers.value[i] = staker.copy();
    box_get
    assert // Box must have value
    frame_dig 4
    assert // Index access is out of bounds
    frame_dig 3
    frame_dig 0
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:277
    // this.stakers.value[i] = staker.copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:278
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    btoi
    frame_dig 5
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:278
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:279
    // actionComplete = true;
    intc_1 // 1
    frame_bury 1

stake_after_if_else@31:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:304
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@33
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:305
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@33:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:262
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b stake_while_top@12

stake_else_body@21:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:280
    // } else if (this.stakers.value[i].account === new arc4.Address(Global.zeroAddress)) {
    box_get
    assert // Box must have value
    frame_dig 3
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    global ZeroAddress
    ==
    bz stake_else_body@29
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:282
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@24
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:283
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@24:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:285
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    btoi
    frame_dig -2
    gtxns AssetAmount
    dup
    frame_bury 6
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:285
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:286
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@26
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:287
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@26:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:290
    // account: new arc4.Address(op.Txn.sender),
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:291
    // stake: new UintN64(stakeTxn.assetAmount),
    frame_dig 6
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-293
    // this.stakers.value[i] = new StakeInfo({
    //   account: new arc4.Address(op.Txn.sender),
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:292
    // accruedASARewards: new UintN64(0),
    bytec 5 // 0x0000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-293
    // this.stakers.value[i] = new StakeInfo({
    //   account: new arc4.Address(op.Txn.sender),
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289
    // this.stakers.value[i] = new StakeInfo({
    box_get
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-293
    // this.stakers.value[i] = new StakeInfo({
    //   account: new arc4.Address(op.Txn.sender),
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    frame_dig 4
    assert // Index access is out of bounds
    frame_dig 3
    uncover 2
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-293
    // this.stakers.value[i] = new StakeInfo({
    //   account: new arc4.Address(op.Txn.sender),
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:294
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz stake_after_if_else@28
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:295
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

stake_after_if_else@28:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:297
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    btoi
    intc_1 // 1
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    bytec_1 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:297
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:298
    // actionComplete = true;
    intc_1 // 1
    frame_bury 1
    b stake_after_if_else@31

stake_else_body@29:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:301
    // assert(this.num_stakers.value.native < MAX_STAKERS_PER_POOL, "Max stakers limit reached");
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:12
    // export const MAX_STAKERS_PER_POOL: uint64 = 500;
    pushint 500 // 500
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:301
    // assert(this.num_stakers.value.native < MAX_STAKERS_PER_POOL, "Max stakers limit reached");
    <
    assert // Max stakers limit reached
    b stake_after_if_else@31

stake_block@35:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:308
    // assert(actionComplete, "Stake  failed");
    frame_dig 1
    assert // Stake  failed
    retsub

stake_bool_false@8:
    intc_0 // 0
    b stake_bool_merge@9


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.accrueRewards() -> void:
accrueRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:311-312
    // @abimethod({ allowActions: "NoOp" })
    // accrueRewards(): void {
    proto 0 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:313
    // if (this.injected_asa_rewards.value.native * 2 > this.num_stakers.value.native) {
    btoi
    pushint 2 // 2
    *
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:313
    // if (this.injected_asa_rewards.value.native * 2 > this.num_stakers.value.native) {
    btoi
    >
    bz accrueRewards_after_if_else@24
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    swap
    frame_bury 0
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:316
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    intc_0 // 0
    frame_bury 4

accrueRewards_while_top@2:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:316
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    btoi
    frame_dig 4
    >
    bz accrueRewards_after_while@23
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:317
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz accrueRewards_after_if_else@5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:318
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

accrueRewards_after_if_else@5:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:321
    // if (this.stakers.value[i].stake.native > 0) {
    box_get
    assert // Box must have value
    frame_dig 4
    intc_2 // 48
    *
    dup
    frame_bury 5
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    pushint 32 // 32
    extract_uint64
    bz accrueRewards_after_if_else@22
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:322
    // const staker = this.stakers.value[i].copy();
    box_get
    assert // Box must have value
    frame_dig 5
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:325
    // let stakerShare = mulDivW(staker.stake.native, PRECISION, this.total_staked.value.native);
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:325
    // let stakerShare = mulDivW(staker.stake.native, PRECISION, this.total_staked.value.native);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    swap
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 10 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    uncover 2
    divw
    frame_bury 8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:327
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz accrueRewards_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:328
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

accrueRewards_after_if_else@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:331
    // if (additionalASARewards.native > 0) {
    frame_dig 0
    btoi
    dup
    frame_bury 2
    bz accrueRewards_after_if_else@22
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    frame_dig 2
    frame_dig 8
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 10 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    divw
    dup
    frame_bury 7
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:334
    // if (rewardRate === 0) {
    bnz accrueRewards_after_if_else@11
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:335
    // rewardRate = 1;
    intc_1 // 1
    frame_bury 7

accrueRewards_after_if_else@11:
    frame_dig 7
    dup
    frame_bury 6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:338
    // if (this.injected_asa_rewards.value.native >= rewardRate) {
    btoi
    <=
    bz accrueRewards_else_body@16
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:339
    // this.injected_asa_rewards.value = new UintN64(this.injected_asa_rewards.value.native - rewardRate);
    btoi
    frame_dig 6
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    bytec_3 // "injected_asa_rewards"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:339
    // this.injected_asa_rewards.value = new UintN64(this.injected_asa_rewards.value.native - rewardRate);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:341
    // if (this.reward_asset_id.value === this.staked_asset_id.value) {
    ==
    bz accrueRewards_else_body@14
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:343
    // staker.stake = new UintN64(staker.stake.native + rewardRate);
    frame_dig 3
    frame_dig 6
    dup
    cover 2
    +
    itob
    frame_dig 1
    swap
    replace2 32
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:344
    // this.total_staked.value = new UintN64(this.total_staked.value.native + rewardRate);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:344
    // this.total_staked.value = new UintN64(this.total_staked.value.native + rewardRate);
    swap
    app_global_put

accrueRewards_after_if_else@20:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:363
    // this.stakers.value[i] = staker.copy();
    box_get
    assert // Box must have value
    frame_dig 4
    intc 6 // 650
    <
    assert // Index access is out of bounds
    frame_dig 5
    frame_dig 1
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:363
    // this.stakers.value[i] = staker.copy();
    swap
    box_put

accrueRewards_after_if_else@22:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:316
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b accrueRewards_while_top@2

accrueRewards_else_body@14:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:346
    // staker.accruedASARewards = new UintN64(staker.accruedASARewards.native + rewardRate);
    frame_dig 1
    dup
    pushint 40 // 40
    extract_uint64
    frame_dig 6
    +
    itob
    replace2 40
    frame_bury 1
    b accrueRewards_after_if_else@20

accrueRewards_else_body@16:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:350
    // if (this.reward_asset_id.value === this.staked_asset_id.value) {
    ==
    bz accrueRewards_else_body@18
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:352
    // const diff: uint64 = rewardRate - this.injected_asa_rewards.value.native;
    btoi
    frame_dig 6
    dup
    uncover 2
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:353
    // staker.stake = new UintN64(staker.stake.native + diff);
    frame_dig 3
    +
    itob
    frame_dig 1
    swap
    replace2 32
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:355
    // this.total_staked.value.native + (rewardRate - this.injected_asa_rewards.value.native)
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "injected_asa_rewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:355
    // this.total_staked.value.native + (rewardRate - this.injected_asa_rewards.value.native)
    btoi
    uncover 2
    swap
    -
    +
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:354-356
    // this.total_staked.value = new UintN64(
    //   this.total_staked.value.native + (rewardRate - this.injected_asa_rewards.value.native)
    // );
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:354-356
    // this.total_staked.value = new UintN64(
    //   this.total_staked.value.native + (rewardRate - this.injected_asa_rewards.value.native)
    // );
    swap
    app_global_put

accrueRewards_after_if_else@19:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // injected_asa_rewards = GlobalState<UintN64>();
    bytec_3 // "injected_asa_rewards"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:360
    // this.injected_asa_rewards.value = new UintN64(0);
    bytec 5 // 0x0000000000000000
    app_global_put
    b accrueRewards_after_if_else@20

accrueRewards_else_body@18:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:358
    // staker.accruedASARewards = new UintN64(staker.accruedASARewards.native + rewardRate);
    frame_dig 1
    dup
    pushint 40 // 40
    extract_uint64
    frame_dig 6
    +
    itob
    replace2 40
    frame_bury 1
    b accrueRewards_after_if_else@19

accrueRewards_after_while@23:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:367
    // this.last_accrual_time.value = new UintN64(Global.latestTimestamp);
    global LatestTimestamp
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:50
    // last_accrual_time = GlobalState<UintN64>();
    pushbytes "last_accrual_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:367
    // this.last_accrual_time.value = new UintN64(Global.latestTimestamp);
    swap
    app_global_put

accrueRewards_after_if_else@24:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.getStaker(address: bytes) -> bytes:
getStaker:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:371
    // private getStaker(address: Address): StakeInfo {
    proto 1 1
    pushbytes ""
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:372
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    intc_0 // 0

getStaker_while_top@1:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:372
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    btoi
    frame_dig 1
    >
    bz getStaker_after_while@7
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:373
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz getStaker_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:374
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

getStaker_after_if_else@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:376
    // if (this.stakers.value[i].account === address) {
    box_get
    assert // Box must have value
    frame_dig 1
    intc_2 // 48
    *
    dup
    frame_bury 0
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz getStaker_after_if_else@6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:377
    // return this.stakers.value[i].copy();
    box_get
    assert // Box must have value
    frame_dig 0
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    frame_bury 0
    retsub

getStaker_after_if_else@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:372
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b getStaker_while_top@1

getStaker_after_while@7:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:380-384
    // return new StakeInfo({
    //   account: new arc4.Address(Global.zeroAddress),
    //   stake: new UintN64(0),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    bytec 13 // base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    frame_bury 0
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.claimRewards() -> void:
claimRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:386-387
    // @abimethod({ allowActions: "NoOp" })
    // claimRewards(): void {
    proto 0 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:388
    // const staker = this.getStaker(new arc4.Address(op.Txn.sender));
    txn Sender
    callsub getStaker
    dupn 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:390
    // if (staker.accruedASARewards.native > 0) {
    pushint 40 // 40
    extract_uint64
    dup
    uncover 2
    swap
    bz claimRewards_after_if_else@3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:391-399
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:393
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:394
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:395
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 1
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:391-398
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:391-399
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:400
    // staker.accruedASARewards = new UintN64(0);
    frame_dig 0
    bytec 5 // 0x0000000000000000
    replace2 40
    frame_bury 2

claimRewards_after_if_else@3:
    frame_dig 2
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:402
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz claimRewards_after_if_else@5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:403
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

claimRewards_after_if_else@5:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:405
    // this.setStaker(staker.account, staker);
    frame_dig 0
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    callsub setStaker
    pop
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.unstake(quantity: uint64) -> void:
unstake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:407-408
    // @abimethod({ allowActions: "NoOp" })
    // unstake(quantity: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:409
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    intc_0 // 0

unstake_while_top@1:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:409
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    btoi
    frame_dig 13
    >
    bz unstake_after_while@33
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:410
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz unstake_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:411
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

unstake_after_if_else@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:413
    // const staker = this.stakers.value[i].copy();
    box_get
    assert // Box must have value
    frame_dig 13
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:414
    // if (staker.account === new arc4.Address(op.Txn.sender)) {
    extract 0 32 // on error: Index access is out of bounds
    txn Sender
    ==
    bz unstake_after_if_else@32
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:415
    // if (staker.stake.native > 0) {
    frame_dig 5
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 10
    bz unstake_after_if_else@18
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:416
    // assert(staker.stake.native >= quantity);
    frame_dig 10
    frame_dig -1
    >=
    assert
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:417
    // if (this.staked_asset_id.value.native === 0) {
    btoi
    bnz unstake_else_body@12
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:418-425
    // itxn
    //   .payment({
    //     amount: quantity === 0 ? staker.stake.native : quantity,
    //     receiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:420
    // amount: quantity === 0 ? staker.stake.native : quantity,
    frame_dig -1
    bnz unstake_ternary_false@9
    frame_dig 10

unstake_ternary_merge@10:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:421
    // receiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:422
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Sender
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:418-424
    // itxn
    //   .payment({
    //     amount: quantity === 0 ? staker.stake.native : quantity,
    //     receiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:423
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:418-425
    // itxn
    //   .payment({
    //     amount: quantity === 0 ? staker.stake.native : quantity,
    //     receiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

unstake_after_if_else@18:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:439
    // if (staker.accruedASARewards.native > 0) {
    frame_dig 5
    dup
    pushint 40 // 40
    extract_uint64
    dup
    frame_bury 11
    swap
    frame_bury 6
    bz unstake_after_if_else@21
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:440-448
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:442
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:443
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:444
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 11
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:440-447
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:440-448
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: staker.accruedASARewards.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:449
    // staker.accruedASARewards = new UintN64(0);
    frame_dig 5
    bytec 5 // 0x0000000000000000
    replace2 40
    frame_bury 6

unstake_after_if_else@21:
    frame_dig 6
    frame_bury 5
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:453
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? staker.stake.native : quantity));
    btoi
    frame_bury 12
    frame_dig -1
    bnz unstake_ternary_false@23
    frame_dig 5
    pushint 32 // 32
    extract_uint64

unstake_ternary_merge@24:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:453
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? staker.stake.native : quantity));
    frame_dig 12
    swap
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:453
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? staker.stake.native : quantity));
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:455
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz unstake_after_if_else@26
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:456
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

unstake_after_if_else@26:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:459
    // if (quantity === 0) {
    frame_dig -1
    bnz unstake_else_body@30
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:465
    // this.setStaker(staker.account, removedStaker);
    frame_dig 5
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:460-464
    // const removedStaker = new StakeInfo({
    //   account: new arc4.Address(Global.zeroAddress),
    //   stake: new UintN64(0),
    //   accruedASARewards: new UintN64(0),
    // }).copy();
    bytec 13 // base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:465
    // this.setStaker(staker.account, removedStaker);
    callsub setStaker
    frame_bury 4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:467
    // const lastStaker = this.getStaker(this.stakers.value[this.num_stakers.value.native - 1].account);
    btoi
    intc_1 // 1
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:467
    // const lastStaker = this.getStaker(this.stakers.value[this.num_stakers.value.native - 1].account);
    box_get
    assert // Box must have value
    swap
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    callsub getStaker
    frame_bury 3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:468
    // const lastStakerIndex = this.getStakerIndex(this.stakers.value[this.num_stakers.value.native - 1].account);
    btoi
    intc_1 // 1
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:468
    // const lastStakerIndex = this.getStakerIndex(this.stakers.value[this.num_stakers.value.native - 1].account);
    box_get
    assert // Box must have value
    swap
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:486
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    intc_0 // 0
    frame_bury 7

unstake_while_top@35:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:486
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    btoi
    frame_dig 7
    >
    bz unstake_after_while@39
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:487
    // if (this.stakers.value[i].account === address) {
    box_get
    assert // Box must have value
    frame_dig 7
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 0
    ==
    bz unstake_after_if_else@38
    frame_dig 7
    frame_bury 9

unstake_after_inlined_smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.getStakerIndex@40:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:469
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz unstake_after_if_else@29
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:470
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

unstake_after_if_else@29:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:472
    // this.setStakerAtIndex(lastStaker, i);
    frame_dig 3
    frame_dig 13
    callsub setStakerAtIndex
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:474
    // this.setStakerAtIndex(removedStaker, lastStakerIndex);
    frame_dig 4
    frame_dig 9
    callsub setStakerAtIndex
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:475
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    btoi
    intc_1 // 1
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    bytec_1 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:475
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    swap
    app_global_put

unstake_after_if_else@31:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:480
    // this.setStaker(staker.account, staker);
    frame_dig 5
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    callsub setStaker
    pop

unstake_after_if_else@32:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:409
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 13
    b unstake_while_top@1

unstake_after_if_else@38:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:486
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    b unstake_while_top@35

unstake_after_while@39:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:491
    // return 0;
    intc_0 // 0
    frame_bury 9
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:468
    // const lastStakerIndex = this.getStakerIndex(this.stakers.value[this.num_stakers.value.native - 1].account);
    b unstake_after_inlined_smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.getStakerIndex@40

unstake_else_body@30:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:477
    // staker.stake = new UintN64(staker.stake.native - quantity);
    frame_dig 5
    dup
    pushint 32 // 32
    extract_uint64
    frame_dig -1
    -
    itob
    replace2 32
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:478
    // staker.accruedASARewards = new UintN64(0);
    bytec 5 // 0x0000000000000000
    replace2 40
    frame_bury 5
    b unstake_after_if_else@31

unstake_ternary_false@23:
    frame_dig -1
    b unstake_ternary_merge@24

unstake_ternary_false@9:
    frame_dig -1
    b unstake_ternary_merge@10

unstake_else_body@12:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:427-435
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? staker.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:429
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    frame_bury 8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:430
    // assetReceiver: op.Txn.sender,
    txn Sender
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:431
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_bury 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:432
    // assetAmount: quantity === 0 ? staker.stake.native : quantity,
    frame_dig -1
    bnz unstake_ternary_false@14
    frame_dig 10

unstake_ternary_merge@15:
    itxn_field AssetAmount
    frame_dig 2
    itxn_field Sender
    frame_dig 1
    itxn_field AssetReceiver
    frame_dig 8
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:427-434
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? staker.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc 5 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:427-435
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? staker.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    b unstake_after_if_else@18

unstake_ternary_false@14:
    frame_dig -1
    b unstake_ternary_merge@15

unstake_after_while@33:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.setStaker(stakerAccount: bytes, staker: bytes) -> bytes:
setStaker:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:494
    // private setStaker(stakerAccount: Address, staker: StakeInfo): void {
    proto 2 1
    pushbytes ""
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:495
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    intc_0 // 0

setStaker_while_top@1:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:56
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:495
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    btoi
    frame_dig 1
    >
    bz setStaker_after_while@10
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:496
    // if (Global.opcodeBudget < 300) {
    global OpcodeBudget
    intc_3 // 300
    <
    bz setStaker_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:497
    // ensureBudget(Global.opcodeBudget + 700);
    global OpcodeBudget
    intc 4 // 700
    +
    intc_0 // 0
    callsub ensure_budget

setStaker_after_if_else@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:499
    // if (this.stakers.value[i].account === stakerAccount) {
    box_get
    assert // Box must have value
    frame_dig 1
    intc_2 // 48
    *
    dup
    frame_bury 0
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    frame_dig -2
    ==
    bz setStaker_else_body@6
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:500
    // this.stakers.value[i] = staker.copy();
    box_get
    assert // Box must have value
    frame_dig 1
    intc 6 // 650
    <
    assert // Index access is out of bounds
    frame_dig 0
    frame_dig -1
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:500
    // this.stakers.value[i] = staker.copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:501
    // return;
    frame_dig -1
    frame_bury 0
    retsub

setStaker_else_body@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:502
    // } else if (this.stakers.value[i].account === new arc4.Address(Global.zeroAddress)) {
    box_get
    assert // Box must have value
    frame_dig 0
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    global ZeroAddress
    ==
    bz setStaker_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:503
    // this.stakers.value[i] = staker.copy();
    box_get
    assert // Box must have value
    frame_dig 1
    intc 6 // 650
    <
    assert // Index access is out of bounds
    frame_dig 0
    frame_dig -1
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:503
    // this.stakers.value[i] = staker.copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:504
    // return;
    frame_dig -1
    frame_bury 0
    retsub

setStaker_after_if_else@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:495
    // for (let i: uint64 = 0; i < this.num_stakers.value.native; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b setStaker_while_top@1

setStaker_after_while@10:
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.setStakerAtIndex(staker: bytes, index: uint64) -> bytes:
setStakerAtIndex:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:508
    // private setStakerAtIndex(staker: StakeInfo, index: uint64): void {
    proto 2 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:509
    // this.stakers.value[index] = staker.copy();
    box_get
    assert // Box must have value
    frame_dig -1
    intc 6 // 650
    <
    assert // Index access is out of bounds
    frame_dig -1
    intc_2 // 48
    *
    frame_dig -2
    replace3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // stakers = Box<StaticArray<StakeInfo, 650>>({ key: "stakers" });
    bytec_0 // "stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:509
    // this.stakers.value[index] = staker.copy();
    swap
    box_put
    frame_dig -2
    retsub
