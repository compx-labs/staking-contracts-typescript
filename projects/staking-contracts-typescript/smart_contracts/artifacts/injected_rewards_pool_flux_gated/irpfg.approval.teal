#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 1000 1000000000000000
    bytecblock "st" "current_asa_reward_index" "total_staked" "admin_address" "staked_asset_id" "reward_asset_id" "num_stakers" 0x0000000000000000 "last_reward_injection_time" "flux_tier_required" "flux_oracle_app"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn NumAppArgs
    bz main_after_if_else@15
    pushbytess 0xd324bea4 0x94202064 0x32db7a6d 0x347007eb 0x2487c32c 0x7a9ee189 0xa5ae6bd1 0x813ce89a 0x3172ca9d // method "createApplication(address)void", method "initApplication(uint64,uint64,pay,uint64,application)void", method "updateAdminAddress(account)void", method "injectRewards(axfer,uint64,uint64)void", method "deleteApplication()void", method "stake(axfer,uint64,pay)void", method "claimRewards()void", method "unstake(uint64)void", method "gas()void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_initApplication_route@4 main_updateAdminAddress_route@5 main_injectRewards_route@6 main_deleteApplication_route@7 main_stake_route@8 main_claimRewards_route@9 main_unstake_route@10 main_gas_route@11

main_after_if_else@15:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    intc_0 // 0
    return

main_gas_route@11:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:327
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_unstake_route@10:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:261
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:261
    // @abimethod({ allowActions: "NoOp" })
    callsub unstake
    intc_1 // 1
    return

main_claimRewards_route@9:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:228
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_stake_route@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:160
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:160
    // @abimethod({ allowActions: "NoOp" })
    callsub stake
    intc_1 // 1
    return

main_deleteApplication_route@7:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:131
    // @abimethod({ allowActions: "DeleteApplication" })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_1 // 1
    return

main_injectRewards_route@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117
    // @abimethod({ allowActions: "NoOp" })
    callsub injectRewards
    intc_1 // 1
    return

main_updateAdminAddress_route@5:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108
    // @abimethod({ allowActions: "NoOp" })
    callsub updateAdminAddress
    intc_1 // 1
    return

main_initApplication_route@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txnas Applications
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    callsub initApplication
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:22-23
    // @contract({ name: "irpfg", avmVersion: 11 })
    // export class InjectedRewardsPoolFluxGated extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.createApplication(adminAddress: bytes) -> void:
createApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:48-49
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // createApplication(adminAddress: Address): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    bytec_3 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:50
    // this.admin_address.value = adminAddress.native;
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:42
    // contract_version = GlobalState<UintN64>();
    pushbytess "contract_version" 0x0000000000000fa0 // "contract_version", 0x0000000000000fa0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:51
    // this.contract_version.value = new UintN64(VERSION);
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.initApplication(stakedAssetId: uint64, rewardAssetId: uint64, initialBalanceTxn: uint64, fluxTierRequired: uint64, fluxOracleApp: uint64) -> void:
initApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:64-71
    // @abimethod({ allowActions: "NoOp" })
    // initApplication(
    //   stakedAssetId: uint64,
    //   rewardAssetId: uint64,
    //   initialBalanceTxn: gtxn.PaymentTxn,
    //   fluxTierRequired: uint64,
    //   fluxOracleApp: Application
    // ): void {
    proto 5 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:72
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec_3 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:72
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    ==
    assert // Only admin can init application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:74
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    frame_dig -5
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    bytec 4 // "staked_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:74
    // this.staked_asset_id.value = new UintN64(stakedAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:75
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    frame_dig -4
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:75
    // this.reward_asset_id.value = new UintN64(rewardAssetId);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:76
    // this.total_staked.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:36
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 8 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:77
    // this.last_reward_injection_time.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    bytec_1 // "current_asa_reward_index"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:78
    // this.current_asa_reward_index.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:79
    // this.num_stakers.value = new UintN64(0);
    bytec 7 // 0x0000000000000000
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    frame_dig -2
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // flux_tier_required = GlobalState<UintN8>();
    bytec 9 // "flux_tier_required"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:80
    // this.flux_tier_required.value = new UintN8(fluxTierRequired);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // flux_oracle_app = GlobalState<Application>();
    bytec 10 // "flux_oracle_app"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:81
    // this.flux_oracle_app.value = fluxOracleApp;
    frame_dig -1
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    frame_dig -3
    gtxns Receiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:84
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    frame_dig -3
    gtxns Amount
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:15
    // export const INITIAL_PAY_AMOUNT: uint64 = 400_000;
    pushint 400000 // 400000
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    bz initApplication_bool_false@3
    intc_1 // 1

initApplication_bool_merge@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:83-86
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-95
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:91
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:92
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -5
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-94
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:88-95
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:96
    // if (rewardAssetId !== stakedAssetId) {
    frame_dig -4
    frame_dig -5
    !=
    bz initApplication_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-104
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:100
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:101
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-103
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:97-104
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

initApplication_after_if_else@8:
    retsub

initApplication_bool_false@3:
    intc_0 // 0
    b initApplication_bool_merge@4


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.updateAdminAddress(adminAddress: bytes) -> void:
updateAdminAddress:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:108-109
    // @abimethod({ allowActions: "NoOp" })
    // updateAdminAddress(adminAddress: Account): void {
    proto 1 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:110
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec_3 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:110
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    ==
    assert // Only admin can update admin address
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    bytec_3 // "admin_address"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:111
    // this.admin_address.value = adminAddress;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.injectRewards(rewardTxn: uint64, quantity: uint64, rewardAssetId: uint64) -> void:
injectRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:117-118
    // @abimethod({ allowActions: "NoOp" })
    // injectRewards(rewardTxn: gtxn.AssetTransferTxn, quantity: uint64, rewardAssetId: uint64): void {
    proto 3 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:119
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec_3 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:119
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can inject rewards");
    ==
    assert // Only admin can inject rewards
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:121-126
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    frame_dig -3
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec_3 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:121-126
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:123
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:121-126
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns XferAsset
    frame_dig -1
    ==
    bz injectRewards_bool_false@5
    frame_dig -3
    gtxns AssetAmount
    frame_dig -2
    ==
    bz injectRewards_bool_false@5
    intc_1 // 1

injectRewards_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:121-126
    // assertMatch(rewardTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(rewardAssetId),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:127
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native + quantity);
    btoi
    frame_dig -2
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    bytec_1 // "current_asa_reward_index"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:127
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native + quantity);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:128
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    global LatestTimestamp
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:36
    // last_reward_injection_time = GlobalState<UintN64>();
    bytec 8 // "last_reward_injection_time"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:128
    // this.last_reward_injection_time.value = new UintN64(Global.latestTimestamp);
    swap
    app_global_put
    retsub

injectRewards_bool_false@5:
    intc_0 // 0
    b injectRewards_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:133
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:38
    // admin_address = GlobalState<Account>();
    intc_0 // 0
    bytec_3 // "admin_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:133
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can delete application");
    ==
    assert // Only admin can delete application
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:134
    // assert(this.total_staked.value.native === 0, "Staked assets still exist");
    btoi
    !
    assert // Staked assets still exist
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:137-145
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:139
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:140
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:142
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:141
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:137-144
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:137-145
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:147
    // if (this.staked_asset_id.value !== this.reward_asset_id.value) {
    !=
    bz deleteApplication_after_if_else@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:148-156
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:150
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:151
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:153
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:152
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:148-155
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:148-156
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetCloseTo: Global.zeroAddress,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

deleteApplication_after_if_else@4:
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.stake(stakeTxn: uint64, quantity: uint64, mbrTxn: uint64) -> void:
stake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:160-161
    // @abimethod({ allowActions: "NoOp" })
    // stake(stakeTxn: gtxn.AssetTransferTxn, quantity: uint64, mbrTxn: gtxn.PaymentTxn): void {
    proto 3 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:162
    // assert(quantity > 0, "Invalid quantity");
    frame_dig -2
    assert // Invalid quantity
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-169
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    frame_dig -3
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:165
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-169
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:166
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-169
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:167
    // xferAsset: Asset(this.staked_asset_id.value.native),
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-169
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    ==
    bz stake_bool_false@5
    frame_dig -3
    gtxns AssetAmount
    frame_dig -2
    ==
    bz stake_bool_false@5
    intc_1 // 1

stake_bool_merge@6:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:164-169
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.native),
    //   assetAmount: quantity,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171-175
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    frame_dig -1
    gtxns Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:172
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171-175
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@10
    frame_dig -1
    gtxns Receiver
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:173
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171-175
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@10
    frame_dig -1
    gtxns Amount
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:17
    // export const BOX_FEE: uint64 = 22_500;
    pushint 22500 // 22500
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171-175
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    bz stake_bool_false@10
    intc_1 // 1

stake_bool_merge@11:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:171-175
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    assert // assert target is match for conditions
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:46
    // flux_oracle_app = GlobalState<Application>();
    intc_0 // 0
    bytec 10 // "flux_oracle_app"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:178
    // const address = oracle.address;
    dup
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:182-189
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:185
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:188
    // accounts: [op.Txn.sender],
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:184
    // args: [new arc4.Address(op.Txn.sender)],
    dup
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:182-189
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    pushbytes 0xd4d7aa5c // method "getUserTier(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field Accounts
    dig 1
    itxn_field Applications
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:182-189
    // const result = abiCall(FluxGateStub.prototype.getUserTier, {
    //   appId: contractAppId,
    //   args: [new arc4.Address(op.Txn.sender)],
    //   sender: Global.currentApplicationAddress,
    //   fee: STANDARD_TXN_FEE,
    //   apps: [oracle],
    //   accounts: [op.Txn.sender],
    // }).returnValue;
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    pushbytes 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:191
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:44
    // flux_tier_required = GlobalState<UintN8>();
    intc_0 // 0
    bytec 9 // "flux_tier_required"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:191
    // assert(result.native >= this.flux_tier_required.value.native, "Insufficient flux tier");
    btoi
    >=
    assert // Insufficient flux tier
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:193
    // const hasLoan = this.stakers(op.Txn.sender).exists;
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:193
    // const hasLoan = this.stakers(op.Txn.sender).exists;
    box_len
    bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:195
    // if (hasLoan) {
    bz stake_else_body@17
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:196
    // if (this.staked_asset_id.value === this.reward_asset_id.value) {
    ==
    bz stake_else_body@15
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199
    // this.current_asa_reward_index.value.native - this.stakers(op.Txn.sender).value.lastRewardIndex.native;
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199
    // this.current_asa_reward_index.value.native - this.stakers(op.Txn.sender).value.lastRewardIndex.native;
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:199
    // this.current_asa_reward_index.value.native - this.stakers(op.Txn.sender).value.lastRewardIndex.native;
    box_get
    assert // Box must have value
    pushint 8 // 8
    extract_uint64
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:200
    // let shareOfTotalStake = mulDivW(this.stakers(op.Txn.sender).value.stake.native, PRECISION, this.total_staked.value.native);
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:200
    // let shareOfTotalStake = mulDivW(this.stakers(op.Txn.sender).value.stake.native, PRECISION, this.total_staked.value.native);
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:200
    // let shareOfTotalStake = mulDivW(this.stakers(op.Txn.sender).value.stake.native, PRECISION, this.total_staked.value.native);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    swap
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    uncover 2
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:202
    // const newStake = new UintN64(this.stakers(op.Txn.sender).value.stake.native + stakeTxn.assetAmount + shareOfRewards);
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:202
    // const newStake = new UintN64(this.stakers(op.Txn.sender).value.stake.native + stakeTxn.assetAmount + shareOfRewards);
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_dig -3
    gtxns AssetAmount
    swap
    dig 1
    +
    dig 2
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:203-206
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: newStake,
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:203
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:203-206
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: newStake,
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:207
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount + shareOfRewards);
    btoi
    +
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:207
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount + shareOfRewards);
    swap
    app_global_put
    retsub

stake_else_body@15:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210
    // const newStake = new UintN64(this.stakers(op.Txn.sender).value.stake.native + stakeTxn.assetAmount);
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:210
    // const newStake = new UintN64(this.stakers(op.Txn.sender).value.stake.native + stakeTxn.assetAmount);
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_dig -3
    gtxns AssetAmount
    swap
    dig 1
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:213
    // lastRewardIndex: this.stakers(op.Txn.sender).value.lastRewardIndex,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:213
    // lastRewardIndex: this.stakers(op.Txn.sender).value.lastRewardIndex,
    box_get
    assert // Box must have value
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:211-214
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: newStake,
    //   lastRewardIndex: this.stakers(op.Txn.sender).value.lastRewardIndex,
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:211
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:211-214
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: newStake,
    //   lastRewardIndex: this.stakers(op.Txn.sender).value.lastRewardIndex,
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:215
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:215
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    swap
    app_global_put
    retsub

stake_else_body@17:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:219
    // stake: new UintN64(stakeTxn.assetAmount),
    frame_dig -3
    gtxns AssetAmount
    dup
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:218-221
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:218
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:218-221
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(stakeTxn.assetAmount),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:223
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    btoi
    intc_1 // 1
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:223
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native + 1);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:224
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:224
    // this.total_staked.value = new UintN64(this.total_staked.value.native + stakeTxn.assetAmount);
    swap
    app_global_put
    retsub

stake_bool_false@10:
    intc_0 // 0
    b stake_bool_merge@11

stake_bool_false@5:
    intc_0 // 0
    b stake_bool_merge@6


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.claimRewards() -> void:
claimRewards:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:228-229
    // @abimethod({ allowActions: "NoOp" })
    // claimRewards(): void {
    proto 0 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:230
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:230
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:232
    // const staker = this.stakers(op.Txn.sender).value.copy();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:232
    // const staker = this.stakers(op.Txn.sender).value.copy();
    box_get
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:234
    // assert(staker.stake.native > 0, "No stake");
    dup
    extract 0 8 // on error: Index access is out of bounds
    swap
    dup
    intc_0 // 0
    extract_uint64
    dup
    assert // No stake
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:237
    // const rewardIndexDiff: uint64 = this.current_asa_reward_index.value.native - staker.lastRewardIndex.native;
    btoi
    uncover 2
    pushint 8 // 8
    extract_uint64
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:238
    // let shareOfTotalStake = mulDivW(staker.stake.native, PRECISION, this.total_staked.value.native);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    uncover 2
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    uncover 2
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    divw
    dup
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:241
    // if (shareOfRewards > 0) {
    bz claimRewards_after_if_else@3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:243
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native - shareOfRewards);
    btoi
    frame_dig 1
    dup
    cover 2
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    bytec_1 // "current_asa_reward_index"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:243
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native - shareOfRewards);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:245-253
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:247
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:248
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:249
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    uncover 3
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:245-252
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:245-253
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

claimRewards_after_if_else@3:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:255-258
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    frame_dig 0
    swap
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:255
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:255-258
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    swap
    box_put
    retsub


// smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts::InjectedRewardsPoolFluxGated.unstake(quantity: uint64) -> void:
unstake:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:261-262
    // @abimethod({ allowActions: "NoOp" })
    // unstake(quantity: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 2
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:263
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:263
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:264
    // const currentRecord = this.stakers(op.Txn.sender).value.copy();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:264
    // const currentRecord = this.stakers(op.Txn.sender).value.copy();
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:265
    // assert(currentRecord.stake.native > 0, "No stake");
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    dup
    assert // No stake
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:267
    // assert(currentRecord.stake.native >= quantity);
    frame_dig -1
    >=
    assert
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272
    // if (currentRecord.lastRewardIndex !== this.current_asa_reward_index.value) {
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:272
    // if (currentRecord.lastRewardIndex !== this.current_asa_reward_index.value) {
    !=
    bz unstake_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:274
    // const rewardIndexDiff: uint64 = this.current_asa_reward_index.value.native - currentRecord.lastRewardIndex.native;
    btoi
    frame_dig 6
    pushint 8 // 8
    extract_uint64
    -
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:275
    // let shareOfTotalStake = mulDivW(currentRecord.stake.native, PRECISION, this.total_staked.value.native);
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    frame_dig 7
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    uncover 2
    divw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:27
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:4
    // export const PRECISION: uint64 = 1_000_000_000_000_000;
    intc 4 // 1000000000000000
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:28
    // return divw(hi, lo, c);
    divw
    dup
    frame_bury 4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:278
    // if (shareOfRewards > 0) {
    bz unstake_after_if_else@8
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:279
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native - shareOfRewards);
    btoi
    frame_dig 4
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    bytec_1 // "current_asa_reward_index"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:279
    // this.current_asa_reward_index.value = new UintN64(this.current_asa_reward_index.value.native - shareOfRewards);
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:281
    // if (this.staked_asset_id.value === this.reward_asset_id.value) {
    ==
    bz unstake_else_body@4
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:284
    // stake: new UintN64(currentRecord.stake.native + shareOfRewards),
    frame_dig 7
    frame_dig 4
    dup
    cover 2
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:283-286
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(currentRecord.stake.native + shareOfRewards),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:283
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:283-286
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(currentRecord.stake.native + shareOfRewards),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    swap
    box_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:287
    // this.total_staked.value = new UintN64(this.total_staked.value.native + shareOfRewards);
    btoi
    +
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:287
    // this.total_staked.value = new UintN64(this.total_staked.value.native + shareOfRewards);
    swap
    app_global_put

unstake_after_if_else@8:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:302
    // const updatedRecord = this.stakers(op.Txn.sender).value.copy();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:302
    // const updatedRecord = this.stakers(op.Txn.sender).value.copy();
    box_get
    swap
    frame_bury 2
    assert // Box must have value
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:303-311
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? updatedRecord.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:28
    // staked_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "staked_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:305
    // xferAsset: this.staked_asset_id.value.native,
    btoi
    frame_bury 3
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:306
    // assetReceiver: op.Txn.sender,
    txn Sender
    frame_bury 0
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:307
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_bury 1
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:308
    // assetAmount: quantity === 0 ? updatedRecord.stake.native : quantity,
    frame_dig -1
    bnz unstake_ternary_false@10
    frame_dig 2
    intc_0 // 0
    extract_uint64

unstake_ternary_merge@11:
    itxn_field AssetAmount
    frame_dig 1
    itxn_field Sender
    frame_dig 0
    itxn_field AssetReceiver
    frame_dig 3
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:303-310
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? updatedRecord.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:303-311
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: quantity === 0 ? updatedRecord.stake.native : quantity,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:315
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? updatedRecord.stake.native : quantity));
    btoi
    frame_bury 5
    frame_dig -1
    bnz unstake_ternary_false@14
    frame_dig 2
    intc_0 // 0
    extract_uint64

unstake_ternary_merge@15:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:315
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? updatedRecord.stake.native : quantity));
    frame_dig 5
    swap
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:32
    // total_staked = GlobalState<UintN64>();
    bytec_2 // "total_staked"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:315
    // this.total_staked.value = new UintN64(this.total_staked.value.native - (quantity === 0 ? updatedRecord.stake.native : quantity));
    swap
    app_global_put
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:316
    // if (quantity === 0) {
    frame_dig -1
    bnz unstake_else_body@17
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:317
    // this.stakers(op.Txn.sender).delete();
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:317
    // this.stakers(op.Txn.sender).delete();
    box_del
    pop
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "num_stakers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:318
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    btoi
    intc_1 // 1
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:40
    // num_stakers = GlobalState<UintN64>();
    bytec 6 // "num_stakers"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:318
    // this.num_stakers.value = new UintN64(this.num_stakers.value.native - 1);
    swap
    app_global_put
    retsub

unstake_else_body@17:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:321
    // stake: new UintN64(updatedRecord.stake.native - quantity),
    frame_dig 2
    intc_0 // 0
    extract_uint64
    frame_dig -1
    -
    itob
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:34
    // current_asa_reward_index = GlobalState<UintN64>();
    intc_0 // 0
    bytec_1 // "current_asa_reward_index"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:320-323
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(updatedRecord.stake.native - quantity),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_0 // "st"
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:320
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:320-323
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new UintN64(updatedRecord.stake.native - quantity),
    //   lastRewardIndex: this.current_asa_reward_index.value,
    // }).copy();
    swap
    box_put
    retsub

unstake_ternary_false@14:
    frame_dig -1
    b unstake_ternary_merge@15

unstake_ternary_false@10:
    frame_dig -1
    b unstake_ternary_merge@11

unstake_else_body@4:
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-297
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:30
    // reward_asset_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "reward_asset_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:291
    // xferAsset: this.reward_asset_id.value.native,
    btoi
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:292
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:293
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 4
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-296
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/injected_rewards_pool_flux_gated/config.algo.ts:16
    // export const STANDARD_TXN_FEE: uint64 = 1_000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/injected_rewards_pool_flux_gated/irpfg.algo.ts:289-297
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.native,
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: shareOfRewards,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    b unstake_after_if_else@8
